{"version":3,"sources":["webpack:///webpack/bootstrap a1e551596f1b10aecb4f","webpack:///./node_modules/ms-rest/dist/node/lib/util/utils.js","webpack:///./node_modules/ms-rest/dist/node/lib/filters/baseFilter.js","webpack:///./node_modules/ms-rest/dist/node/lib/util/constants.js","webpack:///./node_modules/ms-rest/dist/node/lib/webResource.js","webpack:///./lib/util/constants.ts","webpack:///./node_modules/ms-rest/dist/node/lib/msRest.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/ms-rest/node_modules/uuid/lib/rng-browser.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/ms-rest/node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/ms-rest/dist/node/lib/restError.js","webpack:///./node_modules/ms-rest/dist/node/lib/httpOperationResponse.js","webpack:///./node_modules/ms-rest/dist/node/lib/requestPipeline.js","webpack:///./node_modules/ms-rest/dist/node/lib/filters/exponentialRetryPolicyFilter.js","webpack:///./node_modules/ms-rest/dist/node/lib/filters/systemErrorRetryPolicyFilter.js","webpack:///./node_modules/ms-rest/dist/node/lib/filters/redirectFilter.js","webpack:///./node_modules/ms-rest/dist/node/lib/filters/signingFilter.js","webpack:///./node_modules/ms-rest/dist/node/lib/filters/msRestUserAgentFilter.js","webpack:///./node_modules/is-stream/index.js","webpack:///./lib/msRestAzure.ts","webpack:///./lib/azureServiceClient.ts","webpack:///./node_modules/ms-rest/node_modules/uuid/index.js","webpack:///./node_modules/ms-rest/node_modules/uuid/v1.js","webpack:///./node_modules/ms-rest/node_modules/uuid/v4.js","webpack:///./node_modules/form-data/lib/browser.js","webpack:///./node_modules/fetch-ponyfill/build/fetch-browser.js","webpack:///./node_modules/ms-rest/dist/node/lib/serviceClient.js","webpack:///./node_modules/url-parse/index.js","webpack:///./node_modules/requires-port/index.js","webpack:///./node_modules/querystringify/index.js","webpack:///./node_modules/os-browserify/browser.js","webpack:///./node_modules/ms-rest/dist/node/lib/filters/logFilter.js","webpack:///./node_modules/ms-rest/dist/node/lib/serializer.js","webpack:///./node_modules/moment/moment.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/is-buffer/index.js","webpack:///./node_modules/ms-rest/dist/node/lib/credentials/tokenCredentials.js","webpack:///./node_modules/ms-rest/dist/node/lib/credentials/basicAuthenticationCredentials.js","webpack:///./lib/pollingState.ts","webpack:///./lib/cloudError.ts","webpack:///./lib/baseResource.ts"],"names":[],"mappings":";;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;+CC7DA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO,uEAAuE,QAAQ;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ,oCAAoC;AACxD;AACA;AACA,oDAAoD,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,GAAG;AACnH;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA,WAAW,OAAO;AAClB;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6BAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uBAAuB;AAC5B;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,8BAA8B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,YAAY,0BAA0B;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,IAAI,8DAA8D,6BAA6B;AACnI;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iC;;;;;;;;AC1TA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;;ACdA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,qC;;;;;;;AC7EA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA,qDAAqD,qBAAqB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,qBAAqB,+BAA+B,cAAc;AAC3H,8DAA8D,uBAAuB,KAAK,gDAAgD;AAC1I,mGAAmG,GAAG,cAAc,uBAAuB;AAC3I,gEAAgE,IAAI,cAAc,IAAI,oDAAoD,EAAE;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,cAAc;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,wDAAwD;AAC7J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,eAAe;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uC;;;;;;;AC7MA,4DAA4D;AAC5D,+FAA+F;AAE/F,MAAM,SAAS,GAAG;IAChB;;;;;MAKE;IACF,0BAA0B,EAAE;QAC1B,UAAU,EAAE,YAAY;QACxB,SAAS,EAAE,WAAW;QACtB,MAAM,EAAE,QAAQ;QAChB,QAAQ,EAAE,UAAU;KACrB;IAED;;;;;OAKG;IACH,gBAAgB,EAAE,OAAO;IAEzB;;;;OAIG;IACH,kBAAkB,EAAE,OAAO;CAC5B,CAAC;AAEF,yDAAe,SAAS,EAAC;;;;;;;;ACjCzB;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;ACpDA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;ACvLtC;AACA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AChCA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtBA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;ACfA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;ACnCA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2C;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,gBAAgB,QAAQ,6CAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wD;;;;;;;ACnHA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,UAAU;AACzB,gBAAgB,QAAQ,6CAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,wD;;;;;;;AClHA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;;;;AC1DA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;;;;+CChBA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,UAAU,GAAG,UAAU,GAAG,aAAa;AAClE;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;;;;;AChDA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACpBA;AAAA,4DAA4D;AAC5D,+FAA+F;AAEV;AAC5C;AACmB;AACO;AACkE;;;;;;;;;;;ACPrI;AAAA,4DAA4D;AAC5D,gGAAgG;;;;;;;;;AAE9D;AACO;AACC;AAC1C,MAAM,SAAS,GAAG,gEAAS,CAAC,0BAA0B,CAAC;AA8BvD;;;;;;;;GAQG;AACG,wBAA0B,SAAQ,sDAAoB;IAM1D,YAAY,WAA4C,EAAE,OAAmC;QAC3F,KAAK,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;QAN9B,mBAAc,GAAW,gEAAS,CAAC,gBAAgB,CAAC;QACpD,4BAAuB,GAAY,IAAI,CAAC;QACxC,qCAAgC,GAAW,EAAE,CAAC;QAC9C,+BAA0B,GAAW,EAAE,CAAC;QAItC,IAAI,CAAC,cAAc,GAAG,gEAAS,CAAC,gBAAgB,CAAC;QACjD,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC;QACpC,IAAI,CAAC,gCAAgC,GAAG,EAAE,CAAC;QAC3C,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC;YAAC,OAAO,GAAG,EAAE,CAAC;QAE3B,EAAE,CAAC,CAAC,OAAO,CAAC,cAAc,KAAK,IAAI,IAAI,OAAO,CAAC,cAAc,KAAK,SAAS,CAAC,CAAC,CAAC;YAC5E,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;QAC/C,CAAC;QAED,EAAE,CAAC,CAAC,OAAO,CAAC,uBAAuB,KAAK,IAAI,IAAI,OAAO,CAAC,uBAAuB,KAAK,SAAS,CAAC,CAAC,CAAC;YAC9F,IAAI,CAAC,uBAAuB,GAAG,OAAO,CAAC,uBAAuB,CAAC;QACjE,CAAC;QAED,EAAE,CAAC,CAAC,OAAO,CAAC,gCAAgC,KAAK,IAAI,IAAI,OAAO,CAAC,gCAAgC,KAAK,SAAS,CAAC,CAAC,CAAC;YAChH,IAAI,CAAC,gCAAgC,GAAG,OAAO,CAAC,gCAAgC,CAAC;QACnF,CAAC;QAED,EAAE,CAAC,CAAC,OAAO,CAAC,0BAA0B,KAAK,IAAI,IAAI,OAAO,CAAC,0BAA0B,KAAK,SAAS,CAAC,CAAC,CAAC;YACpG,IAAI,CAAC,0BAA0B,GAAG,OAAO,CAAC,0BAA0B,CAAC;QACvE,CAAC;QAED,IAAI,CAAC;YACH,MAAM,UAAU,GAAG,eAAe,CAAC;YACnC,MAAM,aAAa,GAAG,gEAAS,CAAC,kBAAkB,CAAC;YACnD,IAAI,CAAC,gBAAgB,CAAC,GAAG,UAAU,IAAI,aAAa,EAAE,CAAC,CAAC;QAC1D,CAAC;QAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YACb,aAAa;QACf,CAAC;IACH,CAAC;IAED;;;;;OAKG;IACG,sBAAsB,CAAC,OAA0D,EAAE,OAA+B;;YACtH,IAAI,IAAI,GAAG,IAAI,CAAC;YAChB,IAAI,eAA6C,CAAC;YAClD,IAAI,CAAC;gBACH,eAAe,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;YACpD,CAAC;YAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACb,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YAC7B,CAAC;YACD,IAAI,aAA2C,CAAC;YAChD,IAAI,CAAC;gBACH,aAAa,GAAG,MAAM,IAAI,CAAC,6BAA6B,CAAC,eAAe,EAAE,OAAO,CAAC,CAAC;YACrF,CAAC;YAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACb,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YAC7B,CAAC;YACD,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;QACxC,CAAC;KAAA;IAED;;;OAGG;IACK,6BAA6B,CAAC,eAA6C;QACjF,IAAI,UAAU,GAAG,eAAe,CAAC,QAAQ,CAAC,MAAM,CAAC;QACjD,IAAI,MAAM,GAAG,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC;QAC5C,EAAE,CAAC,CAAC,UAAU,KAAK,GAAG,IAAI,UAAU,KAAK,GAAG;YAC1C,CAAC,UAAU,KAAK,GAAG,IAAI,MAAM,KAAK,KAAK,CAAC;YACxC,CAAC,UAAU,KAAK,GAAG,IAAI,CAAC,MAAM,KAAK,QAAQ,IAAI,MAAM,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;YACrE,MAAM,CAAC,KAAK,CAAC;QACf,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,IAAI,CAAC;QACd,CAAC;IACH,CAAC;IAED,iGAAiG;IACjG;;;;;OAKG;IACG,6BAA6B,CAAC,sBAAoD,EAAE,OAA+B;;YACvH,IAAI,IAAI,GAAG,IAAI,CAAC;YAChB,IAAI,oBAAoB,GAAW,sBAAsB,CAAC,OAAO,CAAC,MAA4B,CAAC;YAE/F,EAAE,CAAC,CAAC,IAAI,CAAC,6BAA6B,CAAC,sBAAsB,CAAC,CAAC,CAAC,CAAC;gBAC/D,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,6DAA6D;oBACjF,IAAI,sBAAsB,CAAC,QAAQ,CAAC,MAAM,iBAAiB,oBAAoB,IAAI,CAAC,CAAC;YACzF,CAAC;YACD,IAAI,YAA0B,CAAC;YAC/B,IAAI,CAAC;gBACH,YAAY,GAAG,IAAI,8DAAY,CAAC,sBAAsB,EAAE,IAAI,CAAC,gCAAgC,CAAC,CAAC;gBAC/F,YAAY,CAAC,uBAAuB,GAAG,OAAgC,CAAC;YAC1E,CAAC;YAAC,KAAK,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACf,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAC/B,CAAC;YACD,IAAI,WAAW,GAAW,sBAAsB,CAAC,OAAO,CAAC,GAAG,CAAC;YAC7D,OAAO,CAAC,CAAC,SAAS,CAAC,SAAS,EAAE,SAAS,CAAC,MAAM,EAAE,SAAS,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,MAAM,CAAC,CAAC,KAAK,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;gBACvH,MAAM,8CAAY,CAAC,YAAY,CAAC,UAAU,EAAE,CAAC,CAAC;gBAC9C,EAAE,CAAC,CAAC,YAAY,CAAC,6BAA6B,CAAC,CAAC,CAAC;oBAC/C,MAAM,IAAI,CAAC,wCAAwC,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;gBAC1E,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,YAAY,CAAC,kBAAkB,CAAC,CAAC,CAAC;oBAC3C,MAAM,IAAI,CAAC,6BAA6B,CAAC,oBAAoB,EAAE,YAAY,CAAC,CAAC;gBAC/E,CAAC;gBAAC,IAAI,CAAC,EAAE,CAAC,CAAC,oBAAoB,KAAK,KAAK,CAAC,CAAC,CAAC;oBAC1C,MAAM,IAAI,CAAC,mCAAmC,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;gBAC5E,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC,CAAC;gBAC9F,CAAC;YACH,CAAC;YAED,EAAE,CAAC,CAAC,YAAY,CAAC,MAAM,KAAK,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC;gBAChD,EAAE,CAAC,CAAC,CAAC,YAAY,CAAC,6BAA6B,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC;oBACxE,CAAC,oBAAoB,KAAK,KAAK,IAAI,oBAAoB,KAAK,OAAO,CAAC,CAAC,CAAC,CAAC;oBACvE,MAAM,IAAI,CAAC,mCAAmC,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC;oBAC1E,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,YAAY,CAAC,oBAAoB,EAAE,CAAC,CAAC;gBAC9D,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,YAAY,CAAC,oBAAoB,EAAE,CAAC,CAAC;gBAC9D,CAAC;YACH,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,YAAY,CAAC,YAAY,EAAE,CAAC,CAAC;YACrD,CAAC;QACH,CAAC;KAAA;IAED;;;;OAIG;IACW,wCAAwC,CAAC,YAA0B,EAAE,iBAA0B,KAAK;;YAChH,IAAI,MAAoC,CAAC;YAEzC,IAAI,CAAC;gBACH,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,6BAAuC,EAAE,YAAY,CAAC,uBAAuB,CAAC,CAAC;YAC5H,CAAC;YAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACb,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YAC7B,CAAC;YAED,IAAI,cAAc,GAAG,MAAM,CAAC,UAAoC,CAAC;YAEjE,EAAE,CAAC,CAAC,CAAC,cAAc,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;gBAC9C,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,kGAAkG,CAAC,CAAC,CAAC;YACvI,CAAC;YACD,YAAY,CAAC,MAAM,GAAG,cAAc,CAAC,MAAM,CAAC;YAC5C,YAAY,CAAC,KAAK,GAAG,cAAc,CAAC,KAAK,CAAC;YAC1C,YAAY,CAAC,cAAc,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC7C,YAAY,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC;YACtC,YAAY,CAAC,QAAQ,GAAG,IAAI,CAAC;YAC7B,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;gBACnB,YAAY,CAAC,QAAQ,GAAG,MAAM,CAAC,UAAU,CAAC;YAC5C,CAAC;YACD,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QAC3B,CAAC;KAAA;IAED;;;;OAIG;IACW,6BAA6B,CAAC,MAAc,EAAE,YAA0B;;YACpF,IAAI,MAAoC,CAAC;YACzC,IAAI,CAAC;gBACH,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,kBAA4B,EAAE,YAAY,CAAC,uBAAuB,CAAC,CAAC;YACjH,CAAC;YAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACb,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YAC7B,CAAC;YAED,IAAI,cAAc,GAAG,MAAM,CAAC,UAAoC,CAAC;YACjE,YAAY,CAAC,cAAc,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC7C,YAAY,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC;YACtC,IAAI,UAAU,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC;YACxC,EAAE,CAAC,CAAC,UAAU,KAAK,GAAG,CAAC,CAAC,CAAC;gBACvB,YAAY,CAAC,MAAM,GAAG,SAAS,CAAC,UAAU,CAAC;YAC7C,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,UAAU,KAAK,GAAG;gBAC3B,CAAC,UAAU,KAAK,GAAG,IAAI,MAAM,KAAK,KAAK,CAAC;gBACxC,CAAC,UAAU,KAAK,GAAG,IAAI,CAAC,MAAM,KAAK,QAAQ,IAAI,MAAM,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;gBACrE,YAAY,CAAC,MAAM,GAAG,SAAS,CAAC,SAAS,CAAC;gBAC1C,YAAY,CAAC,QAAQ,GAAG,cAAc,CAAC;gBACvC,gEAAgE;gBAChE,YAAY,CAAC,KAAK,GAAG,IAAI,kDAAgB,CAAC,8CAA8C,YAAY,CAAC,MAAM,IAAI,CAAC,CAAC;gBACjH,YAAY,CAAC,KAAK,CAAC,IAAI,GAAG,YAAY,CAAC,MAAM,CAAC;YAChD,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,iCAAiC,UAAU,oBAAoB;oBAC7F,+BAA+B,YAAY,CAAC,kBAAkB,iBAAiB,CAAC,CAAC,CAAC;YACtF,CAAC;QACH,CAAC;KAAA;IAED;;;;OAIG;IACW,mCAAmC,CAAC,WAAmB,EAAE,YAA0B;;YAC/F,IAAI,MAAoC,CAAC;YACzC,IAAI,CAAC;gBACH,MAAM,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,WAAW,EAAE,YAAY,CAAC,uBAAuB,CAAC,CAAC;YACnF,CAAC;YAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACb,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YAC7B,CAAC;YAED,IAAI,cAAc,GAAG,MAAM,CAAC,UAAoC,CAAC;YACjE,YAAY,CAAC,MAAM,GAAG,SAAS,CAAC,SAAS,CAAC;YAC1C,EAAE,CAAC,CAAC,cAAc,IAAI,cAAc,CAAC,UAAU,IAAI,cAAc,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC,CAAC;gBAC/F,YAAY,CAAC,MAAM,GAAG,cAAc,CAAC,UAAU,CAAC,iBAAiB,CAAC;YACpE,CAAC;YACD,YAAY,CAAC,cAAc,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;YAC7C,YAAY,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC;YACtC,YAAY,CAAC,QAAQ,GAAG,cAAc,CAAC;YACvC,gEAAgE;YAChE,YAAY,CAAC,KAAK,GAAG,IAAI,kDAAgB,CAAC,8CAA8C,YAAY,CAAC,MAAM,IAAI,CAAC,CAAC;YACjH,YAAY,CAAC,KAAK,CAAC,IAAI,GAAG,YAAY,CAAC,MAAM,CAAC;YAC9C,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QAC3B,CAAC;KAAA;IAED;;;;OAIG;IACW,SAAS,CAAC,YAAoB,EAAE,OAA+B;;YAC3E,IAAI,IAAI,GAAG,IAAI,CAAC;YAChB,gBAAgB;YAChB,IAAI,UAAU,GAAG,YAAY,CAAC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;YAClD,6BAA6B;YAC7B,IAAI,WAAW,GAAiC;gBAC9C,MAAM,EAAE,KAAK;gBACb,GAAG,EAAE,UAAU;gBACf,OAAO,EAAE,EAAE;aACZ,CAAC;YACF,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC;gBACZ,IAAI,aAAa,GAA+B,OAAO,CAAC,aAA2C;gBACnG,GAAG,CAAC,CAAC,IAAI,UAAU,IAAI,aAAa,CAAC,CAAC,CAAC;oBACrC,EAAE,CAAC,CAAC,aAAa,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;wBAC5C,WAAW,CAAC,OAAqC,CAAC,UAAU,CAAC,GAAG,aAAa,CAAC,UAAU,CAAC,CAAC;oBAC7F,CAAC;gBACH,CAAC;YACH,CAAC;YACD,IAAI,iBAA+C,CAAC;YACpD,IAAI,CAAC;gBACH,iBAAiB,GAAG,MAAM,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;YAC1D,CAAC;YAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACb,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;YAC7B,CAAC;YACD,IAAI,UAAU,GAAG,iBAAiB,CAAC,QAAQ,CAAC,MAAM,CAAC;YACnD,IAAI,YAAY,GAAG,iBAAiB,CAAC,UAAU,CAAC;YAChD,EAAE,CAAC,CAAC,UAAU,KAAK,GAAG,IAAI,UAAU,KAAK,GAAG,IAAI,UAAU,KAAK,GAAG,IAAI,UAAU,KAAK,GAAG,CAAC,CAAC,CAAC;gBACzF,IAAI,KAAK,GAAG,IAAI,kDAAgB,CAAC,2CAA2C,iBAAiB,CAAC,QAAQ,CAAC,IAAI,aAAa;oBACtH,oCAAoC,CAAC,CAAC;gBACxC,KAAK,CAAC,UAAU,GAAG,UAAU,CAAC;gBAC9B,KAAK,CAAC,OAAO,GAAG,qDAAmB,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC;gBAC/D,KAAK,CAAC,QAAQ,GAAG,iBAAiB,CAAC,QAAQ,CAAC;gBAC5C,IAAI,CAAC;oBACH,KAAK,CAAC,IAAI,GAAG,YAAY,CAAC;gBAC5B,CAAC;gBAAC,KAAK,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;oBACrB,KAAK,CAAC,OAAO,IAAI,WAAW,WAAW,sDAAsD,iBAAiB,CAAC,UAAU,IAAI,CAAC;oBAC9H,KAAK,CAAC,IAAI,GAAG,iBAAiB,CAAC,UAAU,CAAC;gBAC5C,CAAC;gBACD,MAAM,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YAC/B,CAAC;YAED,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;QAC5C,CAAC;KAAA;CACF;AAAA;AAAA;;;;;;;ACrTD;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACPA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;;AAEA;;;;;;;ACnGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;AC5BA;AACA;;;;;;;ACDA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,mBAAmB;AACjE;AACA;;AAEA;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;;AAEA;AACA;AACA,8CAA8C,4BAA4B;AAC1E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D,eAAe;AACf;AACA,eAAe;AACf,oFAAoF;AACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,uBAAuB;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,6CAA6C,0BAA0B;AACvE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,0BAA0B,eAAe;AAC9E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA,WAAW;AACX;AACA;AACA,OAAO;;;AAGP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AAAA;AACL,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,CAAC;;;;;;;;;ACjfD;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,iEAAiE,uBAAuB,EAAE,4BAA4B;AACrJ;AACA,KAAK;AACL;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW,GAAG,cAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yC;;;;;;;8CCzGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yDAAyD;AACzD,GAAG;AACH,sCAAsC;AACtC;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,yBAAyB;AACjC;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACtZA;;AAEA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;ACrCA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACvEA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;;AAE/B,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B;;AAE5B,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;;AAEzB,4BAA4B;;AAE5B,gCAAgC;;AAEhC;AACA;AACA;;AAEA;;;;;;;;AC5CA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,wDAAwD;AAC3F,gDAAgD,kCAAkC;AAClF;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA,qC;;;;;;;ACpBA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW,gBAAgB,MAAM,qDAAqD,oCAAoC;AACtK;AACA;AACA;AACA;AACA,2CAA2C,WAAW,iBAAiB,MAAM,sDAAsD,oCAAoC;AACvK;AACA;AACA;AACA;AACA,2CAA2C,WAAW,gBAAgB,MAAM,qDAAqD,oCAAoC;AACrK;AACA;AACA;AACA;AACA,2CAA2C,WAAW,gBAAgB,MAAM,qDAAqD,oCAAoC;AACrK;AACA;AACA;AACA;AACA,2CAA2C,WAAW,gBAAgB,MAAM,6CAA6C,4BAA4B;AACrJ;AACA;AACA;AACA;AACA,2CAA2C,WAAW,gBAAgB,MAAM,8CAA8C,6BAA6B;AACvJ;AACA;AACA;AACA;AACA,2CAA2C,WAAW,gBAAgB,MAAM,6CAA6C,4BAA4B;AACrJ;AACA;AACA;AACA;AACA,2CAA2C,WAAW,gBAAgB,MAAM,8CAA8C,6BAA6B;AACvJ;AACA;AACA;AACA;AACA,2CAA2C,WAAW,gBAAgB,MAAM,+CAA+C,8BAA8B;AACzJ;AACA;AACA;AACA;AACA,2CAA2C,WAAW,gBAAgB,MAAM,4CAA4C,2BAA2B;AACnJ;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA,yBAAyB,EAAE;AAC3B,+CAA+C,WAAW,gBAAgB,MAAM,gDAAgD,+BAA+B;AAC/J;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW,cAAc,MAAM;AACtE;AACA;AACA;AACA;AACA,uCAAuC,WAAW,eAAe,MAAM;AACvE;AACA;AACA;AACA;AACA,uCAAuC,WAAW,eAAe,MAAM;AACvE;AACA;AACA;AACA;AACA,uCAAuC,WAAW,cAAc,MAAM;AACtE;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,WAAW;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B,MAAM,4BAA4B,WAAW,0BAA0B,8BAA8B;AACpI;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW,mCAAmC,gCAAgC;AAC3I;AACA;AACA;AACA;AACA;AACA,uFAAuF,sBAAsB;AAC7G;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B,aAAa,sBAAsB,gBAAgB,WAAW;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,+CAA+C,IAAI,oCAAoC,WAAW;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,+CAA+C;AAC9D;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,+CAA+C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW,mCAAmC,uBAAuB;AAClI;AACA;AACA;AACA;AACA;AACA,uFAAuF,sBAAsB;AAC7G;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B,aAAa,sBAAsB,sBAAsB,WAAW;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA,2BAA2B,yBAAyB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,+CAA+C;AAC9D;AACA,eAAe,OAAO;AACtB;AACA,iBAAiB,+CAA+C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,WAAW;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK,4CAA4C,WAAW;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C,wBAAwB,+CAA+C;AACvE;AACA;AACA;AACA;AACA,2DAA2D,+CAA+C,kBAAkB,WAAW;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAA+C;AAClF,wBAAwB,uDAAuD,QAAQ,WAAW;AAClG,0FAA0F,mBAAmB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW,kCAAkC,sBAAsB;AACtG;AACA;AACA;AACA,2DAA2D,sBAAsB,kBAAkB,WAAW;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD,wBAAwB,8BAA8B,SAAS,WAAW;AAC1E,0FAA0F,mBAAmB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sC;;;;;;AC9rBA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA,CAAC,qBAAqB;;AAEtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,IAAI;AAC3B;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,IAAI;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wLAAwL,IAAI;;AAE5L,iEAAiE,IAAI;;AAErE;;AAEA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC,YAAY;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B;AAC1B,4BAA4B;AAC5B,yBAAyB,EAAE,EAAE;AAC7B,yBAAyB,EAAE,EAAE;AAC7B,8BAA8B,EAAE,EAAE;AAClC,6BAA6B;AAC7B,iCAAiC;AACjC,qCAAqC;AACrC,yBAAyB,IAAI,EAAE;AAC/B,yBAAyB,IAAI,EAAE;AAC/B,8BAA8B,IAAI,EAAE;;AAEpC,2BAA2B;AAC3B,gCAAgC;;AAEhC,0CAA0C;AAC1C,iDAAiD;;AAEjD,oCAAoC,IAAI,IAAI;;AAE5C;AACA;AACA,4HAA4H,IAAI;;;AAGhI;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,YAAY;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;;AAGA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAuC,EAAE,IAAI,EAAE;AAC/C,oCAAoC,EAAE,IAAI,EAAE;;AAE5C;;AAEA;AACA,6BAA6B,EAAE;AAC/B,uBAAuB,EAAE;AACzB,yBAAyB,EAAE;AAC3B,uBAAuB,EAAE;AACzB,qBAAqB,EAAE,IAAI,EAAE;AAC7B,oBAAoB,EAAE;AACtB,2BAA2B,GAAG;AAC9B,qBAAqB,EAAE;AACvB;AACA,uBAAuB,EAAE,IAAI,EAAE;AAC/B,sBAAsB,EAAE,IAAI,EAAE;AAC9B,oBAAoB,EAAE;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,4MAA4M,EAAE;;AAE9M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;;AAEA;AACA,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,sBAAsB;AACrC;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,8BAA8B,gBAAgB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,6BAA6B;AAClC;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;;AAGD;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gCAAgC,IAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC;;;;;;;;AC92ID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACpBA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA,gEAAgE,yBAAyB,GAAG,WAAW;AACvG;AACA;AACA;AACA;AACA,4C;;;;;;;ACrCA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,qBAAqB;AACtC;AACA;AACA,+BAA+B,cAAc,GAAG,cAAc;AAC9D,sCAAsC,yBAAyB,GAAG,4CAA4C;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0D;;;;;;;;AC5CA;AAAA;AAAA,4DAA4D;AAC5D,gGAAgG;AAEvD;AACP;AAClC,MAAM,SAAS,GAAG,gEAAS,CAAC,0BAA0B,CAAC;AAEvD;;;GAGG;AACW;IA0CZ,YAAY,sBAAoD,EAAE,eAAuB,EAAE;QArB3F;;WAEG;QACH,iBAAY,GAAY,EAAE,CAAC;QAmBzB,IAAI,CAAC,sBAAsB,GAAG,sBAAsB,CAAC;QACrD,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,cAAc,CAAC,sBAAsB,CAAC,QAAQ,CAAC,CAAC;QACrD,IAAI,CAAC,OAAO,GAAG,sBAAsB,CAAC,OAAO,CAAC;QAC9C,IAAI,CAAC,QAAQ,GAAG,sBAAsB,CAAC,UAAU,CAAC;QAElD,MAAM,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;YAC7B,KAAK,GAAG;gBACN,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,UAAU,CAAC;gBACnC,KAAK,CAAC;YAER,KAAK,GAAG;gBACN,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,SAAS,CAAC;gBAClC,KAAK,CAAC;YAER,KAAK,GAAG;gBACN,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC,CAAC;oBAC5F,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,iBAAiB,CAAC;gBAC3D,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,UAAU,CAAC;gBACrC,CAAC;gBACD,KAAK,CAAC;YAER,KAAK,GAAG;gBACN,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,iBAAiB,CAAC,CAAC,CAAC;oBAC5F,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,iBAAiB,CAAC;gBAC3D,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,SAAS,CAAC;gBACpC,CAAC;gBACD,KAAK,CAAC;YAER;gBACE,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC;gBAC/B,KAAK,CAAC;QACV,CAAC;IACH,CAAC;IAED;;;OAGG;IACH,cAAc,CAAC,QAAkB;QAC/B,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,EAAE,CAAC,CAAC,QAAQ,IAAI,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC;YACjC,IAAI,oBAAoB,GAA8B,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAC;YACnG,IAAI,cAAc,GAA8B,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;YACjF,EAAE,CAAC,CAAC,oBAAoB,CAAC,CAAC,CAAC;gBACzB,IAAI,CAAC,6BAA6B,GAAG,oBAAoB,CAAC;YAC5D,CAAC;YAED,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;gBACnB,IAAI,CAAC,kBAAkB,GAAG,cAAc,CAAC;YAC3C,CAAC;QACH,CAAC;IACH,CAAC;IAED;;;OAGG;IACH,UAAU;QACR,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,YAAY,KAAK,CAAC,CAAC,CAAC,CAAC;YACjD,MAAM,CAAC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAClC,CAAC;QACD,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;YAClB,IAAI,UAAU,GAA8B,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;YACrF,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;gBACf,MAAM,CAAC,QAAQ,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;YACrC,CAAC;QACH,CAAC;QACD,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC;IACnB,CAAC;IAED;;;OAGG;IACH,oBAAoB;QAClB,IAAI,MAAM,GAAG,IAAI,8DAA4B,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC/F,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,IAAI,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE,KAAK,QAAQ,CAAC,CAAC,CAAC;YACjE,MAAM,CAAC,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC;YAClC,MAAM,CAAC,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAChD,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC,UAAU,GAAG,IAAI,CAAC,QAAQ,CAAC;YAClC,MAAM,CAAC,UAAU,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACpD,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IAChB,CAAC;IAED;;;;OAIG;IACH,YAAY,CAAC,GAAW;QACtB,IAAI,MAAc,CAAC;QACnB,IAAI,OAAO,GAAkB,IAAI,CAAC;QAElC,IAAI,KAAK,GAAG,IAAI,kDAAgB,CAAC,EAAE,CAAC,CAAC;QACrC,KAAK,CAAC,OAAO,GAAG,qDAAmB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QAClD,KAAK,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;QAC/B,IAAI,cAAc,GAAG,IAAI,CAAC,sBAAsB,CAAC,UAAoC,CAAC;QAEtF,EAAE,CAAC,CAAC,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC;YACvB,MAAM,GAAG,8CAA8C,GAAG,CAAC,OAAO,IAAI,CAAC;QACzE,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,GAAG,+CAA+C,IAAI,CAAC,MAAM,IAAI,CAAC;QAC1E,CAAC;QAED,EAAE,CAAC,CAAC,cAAc,CAAC,CAAC,CAAC;YACnB,EAAE,CAAC,CAAC,cAAc,CAAC,KAAK,IAAI,cAAc,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC;gBACzD,MAAM,GAAG,8CAA8C,cAAc,CAAC,KAAK,CAAC,OAAO,IAAI,CAAC;YAC1F,CAAC;YACD,EAAE,CAAC,CAAC,cAAc,CAAC,KAAK,IAAI,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;gBACtD,OAAO,GAAG,cAAc,CAAC,KAAK,CAAC,IAAc,CAAC;YAChD,CAAC;QACH,CAAC;QAED,KAAK,CAAC,OAAO,GAAG,MAAM,CAAC;QACvB,EAAE,CAAC,CAAC,OAAO,CAAC;YAAC,KAAK,CAAC,IAAI,GAAG,OAAO,CAAC;QAClC,KAAK,CAAC,IAAI,GAAG,cAAc,CAAC;QAC5B,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;CACF;AAAA;AAAA;;;;;;;;ACjLD,4DAA4D;AAC5D,+FAA+F;AAyBxF,MAAM,gBAAgB,GAAG;IAC9B,QAAQ,EAAE,KAAK;IACf,cAAc,EAAE,YAAY;IAC5B,IAAI,EAAE;QACJ,IAAI,EAAE,WAAW;QACjB,SAAS,EAAE,YAAY;QACvB,eAAe,EAAE;YACf,IAAI,EAAE;gBACJ,QAAQ,EAAE,IAAI;gBACd,cAAc,EAAE,MAAM;gBACtB,IAAI,EAAE;oBACJ,IAAI,EAAE,QAAQ;iBACf;aACF;YACD,OAAO,EAAE;gBACP,QAAQ,EAAE,IAAI;gBACd,cAAc,EAAE,SAAS;gBACzB,IAAI,EAAE;oBACJ,IAAI,EAAE,QAAQ;iBACf;aACF;YACD,MAAM,EAAE;gBACN,QAAQ,EAAE,KAAK;gBACf,cAAc,EAAE,QAAQ;gBACxB,IAAI,EAAE;oBACJ,IAAI,EAAE,QAAQ;iBACf;aACF;YACD,OAAO,EAAE;gBACP,QAAQ,EAAE,KAAK;gBACf,cAAc,EAAE,SAAS;gBACzB,IAAI,EAAE;oBACJ,IAAI,EAAE,UAAU;oBAChB,OAAO,EAAE;wBACP,QAAQ,EAAE,KAAK;wBACf,cAAc,EAAE,uBAAuB;wBACvC,IAAI,EAAE;4BACJ,IAAI,EAAE,WAAW;4BACjB,SAAS,EAAE,YAAY;yBACxB;qBACF;iBACF;aACF;SACF;KACF;CACF,CAAC;AAAA;AAAA;;;;;;;;ACvEF,4DAA4D;AAC5D,+FAA+F;AAQxF,MAAM,mBAAmB,GAAG;IACjC,QAAQ,EAAE,KAAK;IACf,cAAc,EAAE,cAAc;IAC9B,IAAI,EAAE;QACJ,IAAI,EAAE,WAAW;QACjB,SAAS,EAAE,cAAc;QACzB,eAAe,EAAE,EAChB;KACF;CACF,CAAC;AAAA;AAAA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 19);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap a1e551596f1b10aecb4f","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst uuid = require(\"uuid\");\nconst FormData = require(\"form-data\");\nconst webResource_1 = require(\"../webResource\");\nconst constants_1 = require(\"./constants\");\nconst restError_1 = require(\"../restError\");\nconst httpOperationResponse_1 = require(\"../httpOperationResponse\");\nconst fPF = require('fetch-ponyfill')();\n/**\n * Checks if a parsed URL is HTTPS\n *\n * @param {object} urlToCheck The url to check\n * @return {boolean} True if the URL is HTTPS; false otherwise.\n */\nfunction urlIsHTTPS(urlToCheck) {\n    return urlToCheck.protocol.toLowerCase() === constants_1.Constants.HTTPS;\n}\nexports.urlIsHTTPS = urlIsHTTPS;\n;\n/**\n * Checks if a value is null or undefined.\n *\n * @param {object} value The value to check for null or undefined.\n * @return {boolean} True if the value is null or undefined, false otherwise.\n */\n// TODO: Audit the usages of this and remove them.\n// Read: https://medium.com/@basarat/null-vs-undefined-in-typescript-land-dc0c7a5f240a\n// https://github.com/Microsoft/TypeScript/issues/7426\nfunction objectIsNull(value) {\n    return value === null || value === undefined;\n}\nexports.objectIsNull = objectIsNull;\n;\n/**\n * Encodes an URI.\n *\n * @param {string} uri The URI to be encoded.\n * @return {string} The encoded URI.\n */\nfunction encodeUri(uri) {\n    return encodeURIComponent(uri)\n        .replace(/!/g, '%21')\n        .replace(/'/g, '%27')\n        .replace(/\\(/g, '%28')\n        .replace(/\\)/g, '%29')\n        .replace(/\\*/g, '%2A');\n}\nexports.encodeUri = encodeUri;\n;\n/**\n * Returns a stripped version of the Http Response which only contains body,\n * headers and the status.\n *\n * @param {nodeFetch.Response} response - The Http Response\n *\n * @return {object} strippedResponse - The stripped version of Http Response.\n */\nfunction stripResponse(response) {\n    const strippedResponse = {};\n    strippedResponse.body = response.body;\n    strippedResponse.headers = response.headers;\n    strippedResponse.status = response.status;\n    return strippedResponse;\n}\nexports.stripResponse = stripResponse;\n/**\n * Returns a stripped version of the Http Request that does not contain the\n * Authorization header.\n *\n * @param {object} request - The Http Request object\n *\n * @return {object} strippedRequest - The stripped version of Http Request.\n */\nfunction stripRequest(request) {\n    let strippedRequest = new webResource_1.WebResource();\n    try {\n        strippedRequest = JSON.parse(JSON.stringify(request));\n        if (strippedRequest.headers && strippedRequest.headers.Authorization) {\n            delete strippedRequest.headers.Authorization;\n        }\n        else if (strippedRequest.headers && strippedRequest.headers.authorization) {\n            delete strippedRequest.headers.authorization;\n        }\n    }\n    catch (err) {\n        const errMsg = err.message;\n        err.message = `Error - '${errMsg}' occured while creating a stripped version of the request object - '${request}'.`;\n        return err;\n    }\n    return strippedRequest;\n}\nexports.stripRequest = stripRequest;\n/**\n * Validates the given uuid as a string\n *\n * @param {string} uuid - The uuid as a string that needs to be validated\n *\n * @return {boolean} result - True if the uuid is valid; false otherwise.\n */\nfunction isValidUuid(uuid) {\n    const validUuidRegex = new RegExp('^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$', 'ig');\n    return validUuidRegex.test(uuid);\n}\nexports.isValidUuid = isValidUuid;\n/**\n * Provides an array of values of an object. For example\n * for a given object { 'a': 'foo', 'b': 'bar' }, the method returns ['foo', 'bar'].\n *\n * @param {object} obj - An object whose properties need to be enumerated so that it's values can be provided as an array\n *\n * @return {array} result - An array of values of the given object.\n */\nfunction objectValues(obj) {\n    const result = [];\n    if (obj && obj instanceof Object) {\n        for (const key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                result.push(obj[key]);\n            }\n        }\n    }\n    else {\n        throw new Error(`The provided object ${JSON.stringify(obj, null, 2)} is not a valid object that can be ` +\n            `enumerated to provide its values as an array.`);\n    }\n    return result;\n}\nexports.objectValues = objectValues;\n/**\n * Generated UUID\n *\n * @return {string} RFC4122 v4 UUID.\n */\nfunction generateUuid() {\n    return uuid.v4();\n}\nexports.generateUuid = generateUuid;\n/*\n * Executes an array of promises sequentially. Inspiration of this method is here:\n * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!\n *\n * @param {Array} promiseFactories An array of promise factories(A function that return a promise)\n *\n * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.\n * If not provided then the promise chain starts with undefined.\n *\n * @return A chain of resolved or rejected promises\n */\nfunction executePromisesSequentially(promiseFactories, kickstart) {\n    let result = Promise.resolve(kickstart);\n    promiseFactories.forEach((promiseFactory) => {\n        result = result.then(promiseFactory);\n    });\n    return result;\n}\nexports.executePromisesSequentially = executePromisesSequentially;\n;\n/*\n * Merges source object into the target object\n * @param {object} source The object that needs to be merged\n *\n * @param {object} target The object to be merged into\n *\n * @returns {object} target - Returns the merged target object.\n */\nfunction mergeObjects(source, target) {\n    Object.keys(source).forEach((key) => {\n        target[key] = source[key];\n    });\n    return target;\n}\nexports.mergeObjects = mergeObjects;\n/**\n * A wrapper for setTimeout that resolves a promise after t milliseconds.\n * @param {number} t - The number of milliseconds to be delayed.\n * @param {T} value - The value to be resolved with after a timeout of t milliseconds.\n * @returns {Promise<T>} - Resolved promise\n */\nfunction delay(t, value) {\n    return new Promise((resolve) => setTimeout(() => resolve(value), t));\n}\nexports.delay = delay;\n/**\n * Utility function to create a K:V from a list of strings\n */\nfunction strEnum(o) {\n    return o.reduce((res, key) => {\n        res[key] = key;\n        return res;\n    }, Object.create(null)); // TODO: Audit usage of null.\n}\nexports.strEnum = strEnum;\n/**\n * Converts a Promise to a callback.\n * @param {Promise<any>} promise - The Promise to be converted to a callback\n * @returns {Function} fn - A function that takes the callback (cb: Function): void\n */\nfunction promiseToCallback(promise) {\n    if (typeof promise.then !== 'function') {\n        throw new Error('The provided input is not a Promise.');\n    }\n    return (cb) => {\n        promise.then((data) => {\n            process.nextTick(cb, null, data);\n        }, (err) => {\n            process.nextTick(cb, err);\n        });\n    };\n}\nexports.promiseToCallback = promiseToCallback;\n/**\n * Converts a Promise to a service callback.\n * @param {Promise<HttpOperationResponse>} promise - The Promise of HttpOperationResponse to be converted to a service callback\n * @returns {Function} fn - A function that takes the service callback (cb: ServiceCallback<T>): void\n */\nfunction promiseToServiceCallback(promise) {\n    if (typeof promise.then !== 'function') {\n        throw new Error('The provided input is not a Promise.');\n    }\n    return (cb) => {\n        promise.then((data) => {\n            process.nextTick(cb, null, data.bodyAsJson, data.request, data.response);\n        }, (err) => {\n            process.nextTick(cb, err);\n        });\n    };\n}\nexports.promiseToServiceCallback = promiseToServiceCallback;\n/**\n * Sends the request and returns the received response.\n * @param {WebResource} options - The request to be sent.\n * @returns {Promise<HttpOperationResponse} operationResponse - The response object.\n */\nfunction dispatchRequest(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!options) {\n            return Promise.reject(new Error('options (WebResource) cannot be null or undefined and must be of type object.'));\n        }\n        if (options.formData) {\n            const formData = options.formData;\n            const requestForm = new FormData();\n            const appendFormValue = (key, value) => {\n                if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {\n                    requestForm.append(key, value.value, value.options);\n                }\n                else {\n                    requestForm.append(key, value);\n                }\n            };\n            for (const formKey in formData) {\n                if (formData.hasOwnProperty(formKey)) {\n                    const formValue = formData[formKey];\n                    if (formValue instanceof Array) {\n                        for (let j = 0; j < formValue.length; j++) {\n                            appendFormValue(formKey, formValue[j]);\n                        }\n                    }\n                    else {\n                        appendFormValue(formKey, formValue);\n                    }\n                }\n            }\n            options.body = requestForm;\n            options.formData = undefined;\n            if (options.headers && options.headers['Content-Type'] &&\n                options.headers['Content-Type'].indexOf('multipart/form-data') > -1 && typeof requestForm.getBoundary === 'function') {\n                options.headers['Content-Type'] = `multipart/form-data; boundary=${requestForm.getBoundary()}`;\n            }\n        }\n        let res;\n        try {\n            res = yield fPF.fetch(options.url, options);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n        const operationResponse = new httpOperationResponse_1.HttpOperationResponse(options, res, res.body);\n        if (!options.rawResponse) {\n            try {\n                operationResponse.bodyAsText = yield res.text();\n            }\n            catch (err) {\n                let msg = `Error \"${err}\" occured while converting the raw response body into string.`;\n                let errCode = err.code || 'RAWTEXT_CONVERSION_ERROR';\n                let e = new restError_1.RestError(msg, errCode, res.status, options, res, res.body);\n                return Promise.reject(e);\n            }\n            try {\n                if (operationResponse.bodyAsText) {\n                    operationResponse.bodyAsJson = JSON.parse(operationResponse.bodyAsText);\n                }\n            }\n            catch (err) {\n                let msg = `Error \"${err}\" occured while executing JSON.parse on the response body - ${operationResponse.bodyAsText}.`;\n                let errCode = err.code || 'JSON_PARSE_ERROR';\n                let e = new restError_1.RestError(msg, errCode, res.status, options, res, operationResponse.bodyAsText);\n                return Promise.reject(e);\n            }\n        }\n        return Promise.resolve(operationResponse);\n    });\n}\nexports.dispatchRequest = dispatchRequest;\n//# sourceMappingURL=utils.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/util/utils.js\n// module id = 0\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BaseFilter {\n    constructor() { }\n    before(request) {\n        return Promise.resolve(request);\n    }\n    after(response) {\n        return Promise.resolve(response);\n    }\n}\nexports.BaseFilter = BaseFilter;\n//# sourceMappingURL=baseFilter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/filters/baseFilter.js\n// module id = 1\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Constants = {\n    /**\n     * The ms-rest version\n     * @const\n     * @type {string}\n     */\n    msRestVersion: '3.0.0',\n    /**\n     * Specifies HTTP.\n     *\n     * @const\n     * @type {string}\n     */\n    HTTP: 'http:',\n    /**\n     * Specifies HTTPS.\n     *\n     * @const\n     * @type {string}\n     */\n    HTTPS: 'https:',\n    /**\n     * Specifies HTTP Proxy.\n     *\n     * @const\n     * @type {string}\n     */\n    HTTP_PROXY: 'HTTP_PROXY',\n    /**\n     * Specifies HTTPS Proxy.\n     *\n     * @const\n     * @type {string}\n     */\n    HTTPS_PROXY: 'HTTPS_PROXY',\n    HttpConstants: {\n        /**\n         * Http Verbs\n         *\n         * @const\n         * @enum {string}\n         */\n        HttpVerbs: {\n            PUT: 'PUT',\n            GET: 'GET',\n            DELETE: 'DELETE',\n            POST: 'POST',\n            MERGE: 'MERGE',\n            HEAD: 'HEAD',\n            PATCH: 'PATCH'\n        },\n    },\n    /**\n     * Defines constants for use with HTTP headers.\n     */\n    HeaderConstants: {\n        /**\n         * The Authorization header.\n         *\n         * @const\n         * @type {string}\n         */\n        AUTHORIZATION: 'authorization',\n        AUTHORIZATION_SCHEME: 'Bearer',\n        /**\n         * The UserAgent header.\n         *\n         * @const\n         * @type {string}\n         */\n        USER_AGENT: 'User-Agent'\n    }\n};\n//# sourceMappingURL=constants.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/util/constants.js\n// module id = 2\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./util/utils\");\n/**\n * Creates a new WebResource object.\n *\n * This class provides an abstraction over a REST call by being library / implementation agnostic and wrapping the necessary\n * properties to initiate a request.\n *\n * @constructor\n */\nclass WebResource {\n    constructor(url, method, body, query, headers = {}, rawResponse = false) {\n        this.headers = {};\n        this.rawResponse = rawResponse;\n        this.url = url || \"\";\n        this.method = method || \"GET\";\n        this.headers = headers || {};\n        this.body = body;\n        this.query = query;\n        this.formData = undefined;\n    }\n    /**\n     * Validates that the required properties such as method, url, headers['Content-Type'],\n     * headers['accept-language'] are defined. It will throw an error if one of the above\n     * mentioned properties are not defined.\n     */\n    validateRequestProperties() {\n        if (!this.method || !this.url || !this.headers['Content-Type'] || !this.headers['accept-language']) {\n            throw new Error('method, url, headers[\\'Content-Type\\'], headers[\\'accept-language\\'] are ' +\n                'required properties before making a request. Either provide them or use WebResource.prepare() method.');\n        }\n        return;\n    }\n    /**\n     * Prepares the request.\n     * @param {RequestPrepareOptions} options - Options to provide for preparing the request.\n     * @returns {object} WebResource Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.\n     */\n    prepare(options) {\n        if (options === null || options === undefined || typeof options !== 'object') {\n            throw new Error('options cannot be null or undefined and must be of type object');\n        }\n        if (options.method === null || options.method === undefined || typeof options.method.valueOf() !== 'string') {\n            throw new Error('options.method cannot be null or undefined and it must be of type string.');\n        }\n        if (options.url && options.pathTemplate) {\n            throw new Error('options.url and options.pathTemplate are mutually exclusive. Please provide either of them.');\n        }\n        if ((options.pathTemplate === null || options.pathTemplate === undefined || typeof options.pathTemplate.valueOf() !== 'string') && (options.url === null || options.url === undefined || typeof options.url.valueOf() !== 'string')) {\n            throw new Error('Please provide either options.pathTemplate or options.url. Currently none of them were provided.');\n        }\n        // set the url if it is provided.\n        if (options.url) {\n            if (typeof options.url !== 'string') {\n                throw new Error('options.url must be of type \\'string\\'.');\n            }\n            this.url = options.url;\n        }\n        // set the method\n        if (options.method) {\n            const validMethods = ['GET', 'PUT', 'HEAD', 'DELETE', 'OPTIONS', 'POST', 'PATCH', 'TRACE'];\n            if (validMethods.indexOf(options.method.toUpperCase()) === -1) {\n                throw new Error('The provided method \\'' + options.method + '\\' is invalid. Supported HTTP methods are: ' + JSON.stringify(validMethods));\n            }\n        }\n        this.method = options.method.toUpperCase();\n        // construct the url if path template is provided\n        if (options.pathTemplate) {\n            if (typeof options.pathTemplate !== 'string') {\n                throw new Error('options.pathTemplate must be of type \\'string\\'.');\n            }\n            if (!options.baseUrl) {\n                options.baseUrl = 'https://management.azure.com';\n            }\n            const baseUrl = options.baseUrl;\n            let url = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + (options.pathTemplate.startsWith('/') ? options.pathTemplate.slice(1) : options.pathTemplate);\n            const segments = url.match(/({\\w*\\s*\\w*})/ig);\n            if (segments && segments.length) {\n                if (options.pathParameters === null || options.pathParameters === undefined || typeof options.pathParameters !== 'object') {\n                    throw new Error(`pathTemplate: ${options.pathTemplate} has been provided. Hence, options.pathParameters ` +\n                        `cannot be null or undefined and must be of type \"object\".`);\n                }\n                segments.forEach(function (item) {\n                    const pathParamName = item.slice(1, -1);\n                    const pathParam = options.pathParameters[pathParamName];\n                    if (pathParam === null || pathParam === undefined || !(typeof pathParam === 'string' || typeof pathParam === 'object')) {\n                        throw new Error(`pathTemplate: ${options.pathTemplate} contains the path parameter ${pathParamName}` +\n                            ` however, it is not present in ${options.pathParameters} - ${JSON.stringify(options.pathParameters, null, 2)}.` +\n                            `The value of the path parameter can either be a \"string\" of the form { ${pathParamName}: \"some sample value\" } or ` +\n                            `it can be an \"object\" of the form { \"${pathParamName}\": { value: \"some sample value\", skipUrlEncoding: true } }.`);\n                    }\n                    if (typeof pathParam.valueOf() === 'string') {\n                        url = url.replace(item, encodeURIComponent(pathParam));\n                    }\n                    if (typeof pathParam.valueOf() === 'object') {\n                        if (!pathParam.value) {\n                            throw new Error(`options.pathParameters[${pathParamName}] is of type \"object\" but it does not contain a \"value\" property.`);\n                        }\n                        if (pathParam.skipUrlEncoding) {\n                            url = url.replace(item, pathParam.value);\n                        }\n                        else {\n                            url = url.replace(item, encodeURIComponent(pathParam.value));\n                        }\n                    }\n                });\n            }\n            this.url = url;\n        }\n        // append query parameters to the url if they are provided. They can be provided with pathTemplate or url option.\n        if (options.queryParameters) {\n            if (typeof options.queryParameters !== 'object') {\n                throw new Error(`options.queryParameters must be of type object. It should be a JSON object ` +\n                    `of \"query-parameter-name\" as the key and the \"query-parameter-value\" as the value. ` +\n                    `The \"query-parameter-value\" may be fo type \"string\" or an \"object\" of the form { value: \"query-parameter-value\", skipUrlEncoding: true }.`);\n            }\n            // append question mark if it is not present in the url\n            if (this.url && this.url.indexOf('?') === -1) {\n                this.url += '?';\n            }\n            // construct queryString\n            const queryParams = [];\n            const queryParameters = options.queryParameters;\n            // We need to populate this.query as a dictionary if the request is being used for Sway's validateRequest().\n            this.query = {};\n            for (const queryParamName in queryParameters) {\n                const queryParam = queryParameters[queryParamName];\n                if (queryParam) {\n                    if (typeof queryParam === 'string') {\n                        queryParams.push(queryParamName + '=' + encodeURIComponent(queryParam));\n                        this.query[queryParamName] = encodeURIComponent(queryParam);\n                    }\n                    else if (typeof queryParam === 'object') {\n                        if (!queryParam.value) {\n                            throw new Error(`options.queryParameters[${queryParamName}] is of type \"object\" but it does not contain a \"value\" property.`);\n                        }\n                        if (queryParam.skipUrlEncoding) {\n                            queryParams.push(queryParamName + '=' + queryParam.value);\n                            this.query[queryParamName] = queryParam.value;\n                        }\n                        else {\n                            queryParams.push(queryParamName + '=' + encodeURIComponent(queryParam.value));\n                            this.query[queryParamName] = encodeURIComponent(queryParam.value);\n                        }\n                    }\n                }\n            } // end-of-for\n            // append the queryString\n            this.url += queryParams.join('&');\n        }\n        // add headers to the request if they are provided\n        if (options.headers) {\n            const headers = options.headers;\n            for (const headerName in headers) {\n                if (headers.hasOwnProperty(headerName)) {\n                    this.headers[headerName] = headers[headerName];\n                }\n            }\n        }\n        // ensure accept-language is set correctly\n        if (!this.headers['accept-language']) {\n            this.headers['accept-language'] = 'en-US';\n        }\n        // ensure the request-id is set correctly\n        if (!this.headers['x-ms-client-request-id'] && !options.disableClientRequestId) {\n            this.headers['x-ms-client-request-id'] = utils_1.generateUuid();\n        }\n        // default\n        if (!this.headers['Content-Type']) {\n            this.headers['Content-Type'] = 'application/json; charset=utf-8';\n        }\n        // set the request body. request.js automatically sets the Content-Length request header, so we need not set it explicilty\n        this.body = null;\n        if (options.body !== null && options.body !== undefined) {\n            // body as a stream special case. set the body as-is and check for some special request headers specific to sending a stream.\n            if (options.bodyIsStream) {\n                this.body = options.body;\n                if (!this.headers['Transfer-Encoding']) {\n                    this.headers['Transfer-Encoding'] = 'chunked';\n                }\n                if (this.headers['Content-Type'] !== 'application/octet-stream') {\n                    this.headers['Content-Type'] = 'application/octet-stream';\n                }\n            }\n            else {\n                // TODO: BUG. we assign this to null and start using it without ever assigning a real value to it.\n                let serializedBody = null;\n                // if (options.serializationMapper) {\n                //   serializedBody = serializer.serialize(options.serializationMapper, options.body, 'requestBody');\n                // }\n                if (options.disableJsonStringifyOnBody) {\n                    this.body = serializedBody || options.body;\n                }\n                else {\n                    this.body = serializedBody ? JSON.stringify(serializedBody) : JSON.stringify(options.body);\n                }\n            }\n        }\n        return this;\n    }\n}\nexports.WebResource = WebResource;\n//# sourceMappingURL=webResource.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/webResource.js\n// module id = 3\n// module chunks = 0","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nconst Constants = {\n  /**\n  * Defines constants for long running operation states.\n  *\n  * @const\n  * @type {string}\n  */\n  LongRunningOperationStates: {\n    InProgress: 'InProgress',\n    Succeeded: 'Succeeded',\n    Failed: 'Failed',\n    Canceled: 'Canceled'\n  },\n\n  /**\n   * The default language in the request header.\n   *\n   * @const\n   * @type {string}\n   */\n  DEFAULT_LANGUAGE: 'en-us',\n\n  /**\n   * The ms-rest-azure version.\n   * @const\n   * @type {string}\n   */\n  msRestAzureVersion: '3.0.0'\n};\n\nexport default Constants;\n\n\n\n// WEBPACK FOOTER //\n// ./lib/util/constants.ts","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst webResource_1 = require(\"./webResource\");\nexports.WebResource = webResource_1.WebResource;\nconst httpOperationResponse_1 = require(\"./httpOperationResponse\");\nexports.HttpOperationResponse = httpOperationResponse_1.HttpOperationResponse;\nconst restError_1 = require(\"./restError\");\nexports.RestError = restError_1.RestError;\nconst serviceClient_1 = require(\"./serviceClient\");\nexports.ServiceClient = serviceClient_1.ServiceClient;\nconst constants_1 = require(\"./util/constants\");\nexports.Constants = constants_1.Constants;\nconst requestPipeline_1 = require(\"./requestPipeline\");\nexports.RequestPipeline = requestPipeline_1.RequestPipeline;\nconst logFilter_1 = require(\"./filters/logFilter\");\nexports.LogFilter = logFilter_1.LogFilter;\nconst baseFilter_1 = require(\"./filters/baseFilter\");\nexports.BaseFilter = baseFilter_1.BaseFilter;\nconst exponentialRetryPolicyFilter_1 = require(\"./filters/exponentialRetryPolicyFilter\");\nexports.ExponentialRetryPolicyFilter = exponentialRetryPolicyFilter_1.ExponentialRetryPolicyFilter;\nconst systemErrorRetryPolicyFilter_1 = require(\"./filters/systemErrorRetryPolicyFilter\");\nexports.SystemErrorRetryPolicyFilter = systemErrorRetryPolicyFilter_1.SystemErrorRetryPolicyFilter;\nconst redirectFilter_1 = require(\"./filters/redirectFilter\");\nexports.RedirectFilter = redirectFilter_1.RedirectFilter;\nconst signingFilter_1 = require(\"./filters/signingFilter\");\nexports.SigningFilter = signingFilter_1.SigningFilter;\nconst msRestUserAgentFilter_1 = require(\"./filters/msRestUserAgentFilter\");\nexports.MsRestUserAgentFilter = msRestUserAgentFilter_1.MsRestUserAgentFilter;\nconst serializer_1 = require(\"./serializer\");\nexports.MapperType = serializer_1.MapperType;\nexports.Serializer = serializer_1.Serializer;\nexports.serializeObject = serializer_1.serializeObject;\nconst utils_1 = require(\"./util/utils\");\nexports.stripRequest = utils_1.stripRequest;\nexports.stripResponse = utils_1.stripResponse;\nexports.delay = utils_1.delay;\nexports.executePromisesSequentially = utils_1.executePromisesSequentially;\nexports.generateUuid = utils_1.generateUuid;\nexports.encodeUri = utils_1.encodeUri;\nexports.promiseToCallback = utils_1.promiseToCallback;\nexports.promiseToServiceCallback = utils_1.promiseToServiceCallback;\nexports.isValidUuid = utils_1.isValidUuid;\nexports.dispatchRequest = utils_1.dispatchRequest;\n// Credentials\nconst tokenCredentials_1 = require(\"./credentials/tokenCredentials\");\nexports.TokenCredentials = tokenCredentials_1.TokenCredentials;\nconst basicAuthenticationCredentials_1 = require(\"./credentials/basicAuthenticationCredentials\");\nexports.BasicAuthenticationCredentials = basicAuthenticationCredentials_1.BasicAuthenticationCredentials;\nconst isStream = require(\"is-stream\");\nexports.isStream = isStream;\n//# sourceMappingURL=msRest.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/msRest.js\n// module id = 5\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 6\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/node_modules/uuid/lib/rng-browser.js\n// module id = 7\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 8\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/node_modules/uuid/lib/bytesToUuid.js\n// module id = 9\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information. \nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass RestError extends Error {\n    constructor(message, code, statusCode, request, response, body) {\n        super(message);\n        this.code = code;\n        this.statusCode = statusCode;\n        this.request = request;\n        this.response = response;\n        this.body = body;\n    }\n}\nexports.RestError = RestError;\n//# sourceMappingURL=restError.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/restError.js\n// module id = 10\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Wrapper object for http request and response. Deserialized object is stored in\n * the `body` property.\n * @class\n * Initializes a new instance of the HttpOperationResponse class.\n * @constructor\n */\nclass HttpOperationResponse {\n    constructor(request, response, body) {\n        /**\n         * Reference to the original request object.\n         * [WebResource] object.\n         * @type {object}\n         */\n        this.request = request;\n        /**\n         * Reference to the original response object.\n         * [ServerResponse] object.\n         * @type {object}\n         */\n        this.response = response;\n        /**\n         * The response object.\n         * @type {object}\n         */\n        this.bodyAsStream = body;\n        this.bodyAsText = null;\n        this.bodyAsJson = null;\n    }\n}\nexports.HttpOperationResponse = HttpOperationResponse;\n//# sourceMappingURL=httpOperationResponse.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/httpOperationResponse.js\n// module id = 11\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = require(\"./util/utils\");\nclass RequestPipeline {\n    constructor(filters, requestOptions) {\n        this.filters = filters || [];\n        this.requestOptions = requestOptions || {};\n    }\n    addFilter(f) {\n        this.filters.push(f);\n        return;\n    }\n    create() {\n        const self = this;\n        let pipeline = [];\n        if (self.filters && self.filters.length) {\n            const beforeFilters = [];\n            const afterFilters = [];\n            for (let i = 0; i < self.filters.length; i++) {\n                const filter = self.filters[i];\n                if (filter.before && typeof filter.before === 'function') {\n                    beforeFilters.push(filter.before.bind(filter));\n                }\n                if (filter.after && typeof filter.after === 'function') {\n                    afterFilters.push(filter.after.bind(filter));\n                }\n            } // end-of-for-loop\n            // add the request sink\n            beforeFilters.push(self.requestSink.bind(self));\n            pipeline = beforeFilters.concat(afterFilters);\n        }\n        else {\n            pipeline.push(self.requestSink.bind(self));\n        }\n        let requestFun = (request) => {\n            if (!request.headers)\n                request.headers = {};\n            return utils.executePromisesSequentially(pipeline, request);\n        };\n        return requestFun;\n    }\n    requestSink(options) {\n        if (this.requestOptions.method)\n            delete this.requestOptions.method;\n        return utils.dispatchRequest(options);\n    }\n}\nexports.RequestPipeline = RequestPipeline;\n//# sourceMappingURL=requestPipeline.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/requestPipeline.js\n// module id = 12\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst baseFilter_1 = require(\"./baseFilter\");\nconst utils = require(\"../util/utils\");\n/**\n * @class\n * Instantiates a new 'ExponentialRetryPolicyFilter' instance.\n *\n * @constructor\n * @param {number} retryCount        The client retry count.\n * @param {number} retryInterval     The client retry interval, in milliseconds.\n * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.\n * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.\n */\nclass ExponentialRetryPolicyFilter extends baseFilter_1.BaseFilter {\n    constructor(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n        super();\n        this.DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\n        this.DEFAULT_CLIENT_RETRY_COUNT = 3;\n        this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\n        this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n        this.retryCount = typeof retryCount === 'number' ? retryCount : this.DEFAULT_CLIENT_RETRY_COUNT;\n        this.retryInterval = typeof retryInterval === 'number' ? retryInterval : this.DEFAULT_CLIENT_RETRY_INTERVAL;\n        this.minRetryInterval = typeof minRetryInterval === 'number' ? minRetryInterval : this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n        this.maxRetryInterval = typeof maxRetryInterval === 'number' ? maxRetryInterval : this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n    }\n    /**\n     * Determines if the operation should be retried and how long to wait until the next retry.\n     *\n     * @param {number} statusCode The HTTP status code.\n     * @param {RetryData} retryData  The retry data.\n     * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n     */\n    shouldRetry(statusCode, retryData) {\n        if ((statusCode < 500 && statusCode !== 408) || statusCode === 501 || statusCode === 505) {\n            return false;\n        }\n        let currentCount;\n        if (!retryData) {\n            throw new Error('retryData for the ExponentialRetryPolicyFilter cannot be null.');\n        }\n        else {\n            currentCount = (retryData && retryData.retryCount);\n        }\n        return (currentCount < this.retryCount);\n    }\n    /**\n     * Updates the retry data for the next attempt.\n     *\n     * @param {RetryData} retryData  The retry data.\n     * @param {object} err        The operation's error, if any.\n     */\n    updateRetryData(retryData, err) {\n        if (!retryData) {\n            retryData = {\n                retryCount: 0,\n                retryInterval: 0\n            };\n        }\n        if (err) {\n            if (retryData.error) {\n                err.innerError = retryData.error;\n            }\n            retryData.error = err;\n        }\n        // Adjust retry count\n        retryData.retryCount++;\n        // Adjust retry interval\n        let incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n        const boundedRandDelta = this.retryInterval * 0.8 +\n            Math.floor(Math.random() * (this.retryInterval * 1.2 - this.retryInterval * 0.8));\n        incrementDelta *= boundedRandDelta;\n        retryData.retryInterval = Math.min(this.minRetryInterval + incrementDelta, this.maxRetryInterval);\n        return retryData;\n    }\n    retry(operationResponse, retryData, err) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const self = this;\n            const response = operationResponse.response;\n            retryData = self.updateRetryData(retryData, err);\n            if (!utils.objectIsNull(response) && self.shouldRetry(response.status, retryData)) {\n                try {\n                    yield utils.delay(retryData.retryInterval);\n                    let res = yield utils.dispatchRequest(operationResponse.request);\n                    return self.retry(res, retryData, err);\n                }\n                catch (err) {\n                    return self.retry(operationResponse, retryData, err);\n                }\n            }\n            else {\n                if (!utils.objectIsNull(err)) {\n                    // If the operation failed in the end, return all errors instead of just the last one\n                    err = retryData.error;\n                    return Promise.reject(err);\n                }\n                return Promise.resolve(operationResponse);\n            }\n        });\n    }\n    after(operationResponse) {\n        return this.retry(operationResponse);\n    }\n}\nexports.ExponentialRetryPolicyFilter = ExponentialRetryPolicyFilter;\n//# sourceMappingURL=exponentialRetryPolicyFilter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/filters/exponentialRetryPolicyFilter.js\n// module id = 13\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst baseFilter_1 = require(\"./baseFilter\");\nconst utils = require(\"../util/utils\");\n/**\n * @class\n * Instantiates a new 'ExponentialRetryPolicyFilter' instance.\n *\n * @constructor\n * @param {number} retryCount        The client retry count.\n * @param {number} retryInterval     The client retry interval, in milliseconds.\n * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.\n * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.\n */\nclass SystemErrorRetryPolicyFilter extends baseFilter_1.BaseFilter {\n    constructor(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {\n        super();\n        this.DEFAULT_CLIENT_RETRY_INTERVAL = 1000 * 30;\n        this.DEFAULT_CLIENT_RETRY_COUNT = 3;\n        this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 90;\n        this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 1000 * 3;\n        this.retryCount = typeof retryCount === 'number' ? retryCount : this.DEFAULT_CLIENT_RETRY_COUNT;\n        this.retryInterval = typeof retryInterval === 'number' ? retryInterval : this.DEFAULT_CLIENT_RETRY_INTERVAL;\n        this.minRetryInterval = typeof minRetryInterval === 'number' ? minRetryInterval : this.DEFAULT_CLIENT_MIN_RETRY_INTERVAL;\n        this.maxRetryInterval = typeof maxRetryInterval === 'number' ? maxRetryInterval : this.DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n    }\n    /**\n     * Determines if the operation should be retried and how long to wait until the next retry.\n     *\n     * @param {number} statusCode The HTTP status code.\n     * @param {RetryData} retryData  The retry data.\n     * @return {boolean} True if the operation qualifies for a retry; false otherwise.\n     */\n    shouldRetry(retryData) {\n        let currentCount;\n        if (!retryData) {\n            throw new Error('retryData for the SystemErrorRetryPolicyFilter cannot be null.');\n        }\n        else {\n            currentCount = (retryData && retryData.retryCount);\n        }\n        return (currentCount < this.retryCount);\n    }\n    /**\n     * Updates the retry data for the next attempt.\n     *\n     * @param {RetryData} retryData  The retry data.\n     * @param {object} err        The operation's error, if any.\n     */\n    updateRetryData(retryData, err) {\n        if (!retryData) {\n            retryData = {\n                retryCount: 0,\n                retryInterval: 0\n            };\n        }\n        if (err) {\n            if (retryData.error) {\n                err.innerError = retryData.error;\n            }\n            retryData.error = err;\n        }\n        // Adjust retry count\n        retryData.retryCount++;\n        // Adjust retry interval\n        let incrementDelta = Math.pow(2, retryData.retryCount) - 1;\n        const boundedRandDelta = this.retryInterval * 0.8 +\n            Math.floor(Math.random() * (this.retryInterval * 1.2 - this.retryInterval * 0.8));\n        incrementDelta *= boundedRandDelta;\n        retryData.retryInterval = Math.min(this.minRetryInterval + incrementDelta, this.maxRetryInterval);\n        return retryData;\n    }\n    retry(operationResponse, retryData, err) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const self = this;\n            retryData = self.updateRetryData(retryData, err);\n            if (err && err.code && self.shouldRetry(retryData) &&\n                (err.code === 'ETIMEDOUT' || err.code === 'ESOCKETTIMEDOUT' || err.code === 'ECONNREFUSED' ||\n                    err.code === 'ECONNRESET' || err.code === 'ENOENT')) {\n                // If previous operation ended with an error and the policy allows a retry, do that\n                try {\n                    yield utils.delay(retryData.retryInterval);\n                    let res = yield utils.dispatchRequest(operationResponse.request);\n                    return self.retry(res, retryData, err);\n                }\n                catch (err) {\n                    return self.retry(operationResponse, retryData, err);\n                }\n            }\n            else {\n                if (!utils.objectIsNull(err)) {\n                    // If the operation failed in the end, return all errors instead of just the last one\n                    err = retryData.error;\n                    return Promise.reject(err);\n                }\n                return Promise.resolve(operationResponse);\n            }\n        });\n    }\n    after(operationResponse) {\n        return this.retry(operationResponse); //See: https://github.com/Microsoft/TypeScript/issues/7426\n    }\n}\nexports.SystemErrorRetryPolicyFilter = SystemErrorRetryPolicyFilter;\n//# sourceMappingURL=systemErrorRetryPolicyFilter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/filters/systemErrorRetryPolicyFilter.js\n// module id = 14\n// module chunks = 0","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nconst baseFilter_1 = require(\"./baseFilter\");\nconst utils = require(\"../util/utils\");\nconst parse = require('url-parse');\nclass RedirectFilter extends baseFilter_1.BaseFilter {\n    constructor(maximumRetries = 20) {\n        super();\n        this.maximumRetries = maximumRetries;\n    }\n    handleRedirect(operationResponse, currentRetries) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let request = operationResponse.request;\n            let response = operationResponse.response;\n            if (response && response.headers && response.headers.get('location') &&\n                (response.status === 300 || response.status === 307 || (response.status === 303 && request.method === 'POST')) &&\n                (!this.maximumRetries || currentRetries < this.maximumRetries)) {\n                if (parse(response.headers.get('location')).hostname) {\n                    request.url = response.headers.get('location');\n                }\n                else {\n                    let urlObject = parse(request.url);\n                    urlObject.set('pathname', response.headers.get('location'));\n                    request.url = urlObject.href;\n                }\n                // POST request with Status code 303 should be converted into a \n                // redirected GET request if the redirect url is present in the location header\n                if (response.status === 303) {\n                    request.method = 'GET';\n                }\n                let res;\n                try {\n                    res = yield utils.dispatchRequest(request);\n                    currentRetries++;\n                }\n                catch (err) {\n                    return Promise.reject(err);\n                }\n                return this.handleRedirect(res, currentRetries);\n            }\n            return Promise.resolve(operationResponse);\n        });\n    }\n    after(operationResponse) {\n        return this.handleRedirect(operationResponse, 0);\n    }\n}\nexports.RedirectFilter = RedirectFilter;\n//# sourceMappingURL=redirectFilter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/filters/redirectFilter.js\n// module id = 15\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst baseFilter_1 = require(\"./baseFilter\");\nclass SigningFilter extends baseFilter_1.BaseFilter {\n    constructor(authenticationProvider) {\n        super();\n        this.authenticationProvider = authenticationProvider;\n    }\n    before(request) {\n        const self = this;\n        return self.authenticationProvider.signRequest(request);\n    }\n}\nexports.SigningFilter = SigningFilter;\n//# sourceMappingURL=signingFilter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/filters/signingFilter.js\n// module id = 16\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst baseFilter_1 = require(\"./baseFilter\");\nconst constants_1 = require(\"../util/constants\");\nconst os = require(\"os\");\nconst HeaderConstants = constants_1.Constants.HeaderConstants;\nclass MsRestUserAgentFilter extends baseFilter_1.BaseFilter {\n    constructor(userAgentInfo) {\n        super();\n        this.userAgentInfo = userAgentInfo;\n    }\n    tagRequest(request) {\n        const osInfo = `(${os.arch()}-${os.type()}-${os.release()})`;\n        if (this.userAgentInfo.indexOf(osInfo) === -1) {\n            this.userAgentInfo.unshift(osInfo);\n        }\n        const runtimeInfo = `Node/${process.version}`;\n        if (this.userAgentInfo.indexOf(runtimeInfo) === -1) {\n            this.userAgentInfo.unshift(runtimeInfo);\n        }\n        const nodeSDKSignature = `Azure-SDK-For-Node`;\n        if (this.userAgentInfo.indexOf(nodeSDKSignature) === -1) {\n            const azureRuntime = `ms-rest-azure`;\n            let insertIndex = this.userAgentInfo.indexOf(azureRuntime);\n            // insert after azureRuntime, otherwise, insert last.\n            insertIndex = insertIndex < 0 ? this.userAgentInfo.length : insertIndex + 1;\n            this.userAgentInfo.splice(insertIndex, 0, nodeSDKSignature);\n        }\n        if (!request.headers)\n            request.headers = {};\n        request.headers[HeaderConstants.USER_AGENT] = this.userAgentInfo.join(' ');\n        return Promise.resolve(request);\n    }\n    before(request) {\n        const self = this;\n        if (!request.headers)\n            request.headers = {};\n        if (!request.headers[HeaderConstants.USER_AGENT]) {\n            return self.tagRequest(request);\n        }\n        else {\n            return Promise.resolve(request);\n        }\n    }\n}\nexports.MsRestUserAgentFilter = MsRestUserAgentFilter;\n//# sourceMappingURL=msRestUserAgentFilter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/filters/msRestUserAgentFilter.js\n// module id = 17\n// module chunks = 0","'use strict';\n\nvar isStream = module.exports = function (stream) {\n\treturn stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';\n};\n\nisStream.writable = function (stream) {\n\treturn isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';\n};\n\nisStream.readable = function (stream) {\n\treturn isStream(stream) && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';\n};\n\nisStream.duplex = function (stream) {\n\treturn isStream.writable(stream) && isStream.readable(stream);\n};\n\nisStream.transform = function (stream) {\n\treturn isStream.duplex(stream) && typeof stream._transform === 'function' && typeof stream._transformState === 'object';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/is-stream/index.js\n// module id = 18\n// module chunks = 0","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\n\nimport { AzureServiceClientOptions, AzureServiceClient } from './azureServiceClient';\nimport Constants from './util/constants';\nimport { CloudError, CloudErrorMapper } from './cloudError';\nimport { BaseResource, BaseResourcerMapper } from './baseResource';\nexport { AzureServiceClient, AzureServiceClientOptions, Constants, CloudError, CloudErrorMapper, BaseResource, BaseResourcerMapper };\n\n\n// WEBPACK FOOTER //\n// ./lib/msRestAzure.ts","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information. \n\nimport * as msRest from 'ms-rest';\nimport Constants from './util/constants';\nimport PollingState from './pollingState';\nconst LroStates = Constants.LongRunningOperationStates;\n\n/**\n * Options to be provided while creating the client. \n */\nexport interface AzureServiceClientOptions extends msRest.ServiceClientOptions {\n  /**\n   * @property {string} [options.acceptLanguage] - Gets or sets the preferred language for the response. Default value is: 'en-US'.\n   */\n  acceptLanguage?: string;\n\n  /**\n   * @property {boolean} [options.generateClientRequestId] - When set to true a unique x-ms-client-request-id value \n   * is generated and included in each request. Default is true.\n   */\n  generateClientRequestId?: boolean;\n\n  /**\n   * @property {number} [options.longRunningOperationRetryTimeout] - Gets or sets the retry timeout in seconds for \n   * Long Running Operations. Default value is 30.\n   */\n  longRunningOperationRetryTimeout?: number;\n\n  /**\n   * @property {number} [rpRegistrationRetryTimeout] - Gets or sets the retry timeout in seconds for \n   * AutomaticRPRegistration. Default value is 30 seconds.\n   */\n  rpRegistrationRetryTimeout?: number;\n}\n\n/**\n * @class\n * Initializes a new instance of the AzureServiceClient class.\n * @constructor\n * \n * @param {msRest.ServiceClientCredentilas} credentials - ApplicationTokenCredentials or \n * UserTokenCredentials object used for authentication.  \n * @param {AzureServiceClientOptions} options - The parameter options used by AzureServiceClient\n */\nexport class AzureServiceClient extends msRest.ServiceClient {\n  acceptLanguage: string = Constants.DEFAULT_LANGUAGE;\n  generateClientRequestId: boolean = true;\n  longRunningOperationRetryTimeout: number = 30;\n  rpRegistrationRetryTimeout: number = 30;\n\n  constructor(credentials: msRest.ServiceClientCredentials, options?: AzureServiceClientOptions) {\n    super(credentials, options);\n    this.acceptLanguage = Constants.DEFAULT_LANGUAGE;\n    this.generateClientRequestId = true;\n    this.longRunningOperationRetryTimeout = 30;\n    if (!options) options = {};\n\n    if (options.acceptLanguage !== null && options.acceptLanguage !== undefined) {\n      this.acceptLanguage = options.acceptLanguage;\n    }\n\n    if (options.generateClientRequestId !== null && options.generateClientRequestId !== undefined) {\n      this.generateClientRequestId = options.generateClientRequestId;\n    }\n\n    if (options.longRunningOperationRetryTimeout !== null && options.longRunningOperationRetryTimeout !== undefined) {\n      this.longRunningOperationRetryTimeout = options.longRunningOperationRetryTimeout;\n    }\n\n    if (options.rpRegistrationRetryTimeout !== null && options.rpRegistrationRetryTimeout !== undefined) {\n      this.rpRegistrationRetryTimeout = options.rpRegistrationRetryTimeout;\n    }\n\n    try {\n      const moduleName = 'ms-rest-azure';\n      const moduleVersion = Constants.msRestAzureVersion;\n      this.addUserAgentInfo(`${moduleName}/${moduleVersion}`);\n    } catch (err) {\n      // do nothing\n    }\n  }\n\n  /**\n   * Provides a mechanism to make a request that will poll and provide the final result.\n   * @param {msRest.RequestPrepareOptions|msRest.WebResource} request - The request object\n   * @param {msRest.RequestOptions} [options] Additional options to be sent while making the request\n   * @returns {Promise<msRest.HttpOperationResponse>} The HttpOperationResponse containing the final polling request, response and the responseBody.\n   */\n  async sendLongRunningRequest(request: msRest.RequestPrepareOptions | msRest.WebResource, options?: msRest.RequestOptions): Promise<msRest.HttpOperationResponse> {\n    let self = this;\n    let initialResponse: msRest.HttpOperationResponse;\n    try {\n      initialResponse = await self.sendRequest(request);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n    let finalResponse: msRest.HttpOperationResponse;\n    try {\n      finalResponse = await self.getLongRunningOperationResult(initialResponse, options);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n    return Promise.resolve(finalResponse);\n  }\n\n  /**\n   * Verified whether an unexpected polling status code for long running operation was received for the response of the initial request.\n   * @param {msRest.HttpOperationResponse} initialResponse - Response to the initial request that was sent as a part of the asynchronous operation.\n   */\n  private checkResponseStatusCodeFailed(initialResponse: msRest.HttpOperationResponse): boolean {\n    let statusCode = initialResponse.response.status;\n    let method = initialResponse.request.method;\n    if (statusCode === 200 || statusCode === 202 ||\n      (statusCode === 201 && method === 'PUT') ||\n      (statusCode === 204 && (method === 'DELETE' || method === 'POST'))) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  //goal is to get this working without using the async package and simply using async and Promise.\n  /**\n   * Poll Azure long running PUT, PATCH, POST or DELETE operations.\n   * @param {msRest.HttpOperationResponse} resultOfInitialRequest - result/response of the initial request which is a part of the asynchronous polling operation.\n   * @param {msRest.RequestOptions} [options] - custom request options.\n   * @returns {Promise<msRest.HttpOperationResponse>} result - The final response after polling is complete.\n   */\n  async getLongRunningOperationResult(resultOfInitialRequest: msRest.HttpOperationResponse, options?: msRest.RequestOptions): Promise<msRest.HttpOperationResponse> {\n    let self = this;\n    let initialRequestMethod: string = resultOfInitialRequest.request.method as msRest.HttpMethods;\n\n    if (self.checkResponseStatusCodeFailed(resultOfInitialRequest)) {\n      return Promise.reject(`Unexpected polling status code from long running operation ` +\n        `\"${resultOfInitialRequest.response.status}\" for method \"${initialRequestMethod}\".`);\n    }\n    let pollingState: PollingState;\n    try {\n      pollingState = new PollingState(resultOfInitialRequest, self.longRunningOperationRetryTimeout);\n      pollingState.optionsOfInitialRequest = options as msRest.RequestOptions;\n    } catch (error) {\n      return Promise.reject(error);\n    }\n    let resourceUrl: string = resultOfInitialRequest.request.url;\n    while (![LroStates.Succeeded, LroStates.Failed, LroStates.Canceled].some((e) => { return e === pollingState.status; })) {\n      await msRest.delay(pollingState.getTimeout());\n      if (pollingState.azureAsyncOperationHeaderLink) {\n        await self.updateStateFromAzureAsyncOperationHeader(pollingState, true);\n      } else if (pollingState.locationHeaderLink) {\n        await self.updateStateFromLocationHeader(initialRequestMethod, pollingState);\n      } else if (initialRequestMethod === 'PUT') {\n        await self.updateStateFromGetResourceOperation(resourceUrl, pollingState);\n      } else {\n        return Promise.reject(new Error('Location header is missing from long running operation.'));\n      }\n    }\n\n    if (pollingState.status === LroStates.Succeeded) {\n      if ((pollingState.azureAsyncOperationHeaderLink || !pollingState.resource) &&\n        (initialRequestMethod === 'PUT' || initialRequestMethod === 'PATCH')) {\n        await self.updateStateFromGetResourceOperation(resourceUrl, pollingState);\n        return Promise.resolve(pollingState.getOperationResponse());\n      } else {\n        return Promise.resolve(pollingState.getOperationResponse());\n      }\n    } else {\n      return Promise.reject(pollingState.getRestError());\n    }\n  }\n\n  /**\n   * Retrieve operation status by polling from 'azure-asyncoperation' header.\n   * @param {PollingState} pollingState - The object to persist current operation state.\n   * @param {boolean} inPostOrDelete - Invoked by Post Or Delete operation.\n   */\n  private async updateStateFromAzureAsyncOperationHeader(pollingState: PollingState, inPostOrDelete: boolean = false): Promise<void> {\n    let result: msRest.HttpOperationResponse;\n\n    try {\n      result = await this.getStatus(pollingState.azureAsyncOperationHeaderLink as string, pollingState.optionsOfInitialRequest);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    let parsedResponse = result.bodyAsJson as { [key: string]: any };\n\n    if (!parsedResponse || !parsedResponse.status) {\n      return Promise.reject(new Error('The response \"${responseBody}\" from long running operation does not contain the status property.'));\n    }\n    pollingState.status = parsedResponse.status;\n    pollingState.error = parsedResponse.error;\n    pollingState.updateResponse(result.response);\n    pollingState.request = result.request;\n    pollingState.resource = null;\n    if (inPostOrDelete) {\n      pollingState.resource = result.bodyAsJson;\n    }\n    return Promise.resolve();\n  }\n\n  /**\n   * Retrieve PUT operation status by polling from 'location' header.\n   * @param {string} method - The HTTP method.\n   * @param {PollingState} pollingState - The object to persist current operation state.\n   */\n  private async updateStateFromLocationHeader(method: string, pollingState: PollingState): Promise<void> {\n    let result: msRest.HttpOperationResponse;\n    try {\n      result = await this.getStatus(pollingState.locationHeaderLink as string, pollingState.optionsOfInitialRequest);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    let parsedResponse = result.bodyAsJson as { [key: string]: any };\n    pollingState.updateResponse(result.response);\n    pollingState.request = result.request;\n    let statusCode = result.response.status;\n    if (statusCode === 202) {\n      pollingState.status = LroStates.InProgress;\n    } else if (statusCode === 200 ||\n      (statusCode === 201 && method === 'PUT') ||\n      (statusCode === 204 && (method === 'DELETE' || method === 'POST'))) {\n      pollingState.status = LroStates.Succeeded;\n      pollingState.resource = parsedResponse;\n      //we might not throw an error, but initialize here just in case.\n      pollingState.error = new msRest.RestError(`Long running operation failed with status \"${pollingState.status}\".`);\n      pollingState.error.code = pollingState.status;\n    } else {\n      return Promise.reject(new Error(`The response with status code ${statusCode} from polling for ` +\n        `long running operation url \"${pollingState.locationHeaderLink}\" is not valid.`));\n    }\n  }\n\n  /**\n   * Polling for resource status.\n   * @param {string} resourceUrl - The url of resource.\n   * @param {PollingState} pollingState - The object to persist current operation state.\n   */\n  private async updateStateFromGetResourceOperation(resourceUrl: string, pollingState: PollingState): Promise<void> {\n    let result: msRest.HttpOperationResponse;\n    try {\n      result = await this.getStatus(resourceUrl, pollingState.optionsOfInitialRequest);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    let parsedResponse = result.bodyAsJson as { [key: string]: any };\n    pollingState.status = LroStates.Succeeded;\n    if (parsedResponse && parsedResponse.properties && parsedResponse.properties.provisioningState) {\n      pollingState.status = parsedResponse.properties.provisioningState;\n    }\n    pollingState.updateResponse(result.response);\n    pollingState.request = result.request;\n    pollingState.resource = parsedResponse;\n    //we might not throw an error, but initialize here just in case.\n    pollingState.error = new msRest.RestError(`Long running operation failed with status \"${pollingState.status}\".`);\n    pollingState.error.code = pollingState.status;\n    return Promise.resolve();\n  }\n\n  /**\n   * Retrieves operation status by querying the operation URL.\n   * @param {string} operationUrl - URL used to poll operation result.\n   * @param {object} options - Options that can be set on the request object\n   */\n  private async getStatus(operationUrl: string, options?: msRest.RequestOptions): Promise<msRest.HttpOperationResponse> {\n    let self = this;\n    // Construct URL\n    let requestUrl = operationUrl.replace(' ', '%20');\n    // Create HTTP request object\n    let httpRequest: msRest.RequestPrepareOptions = {\n      method: 'GET',\n      url: requestUrl,\n      headers: {}\n    };\n    if (options) {\n      let customHeaders: { [key: string]: string } = (options.customHeaders as { [key: string]: string })\n      for (let headerName in customHeaders) {\n        if (customHeaders.hasOwnProperty(headerName)) {\n          (httpRequest.headers as { [key: string]: string })[headerName] = customHeaders[headerName];\n        }\n      }\n    }\n    let operationResponse: msRest.HttpOperationResponse;\n    try {\n      operationResponse = await self.sendRequest(httpRequest);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n    let statusCode = operationResponse.response.status;\n    let responseBody = operationResponse.bodyAsJson;\n    if (statusCode !== 200 && statusCode !== 201 && statusCode !== 202 && statusCode !== 204) {\n      let error = new msRest.RestError(`Invalid status code with response body \"${operationResponse.response.body}\" occurred ` +\n        `when polling for operation status.`);\n      error.statusCode = statusCode;\n      error.request = msRest.stripRequest(operationResponse.request);\n      error.response = operationResponse.response;\n      try {\n        error.body = responseBody;\n      } catch (badResponse) {\n        error.message += ` Error \"${badResponse}\" occured while deserializing the response body - \"${operationResponse.bodyAsText}\".`;\n        error.body = operationResponse.bodyAsText;\n      }\n      return Promise.reject(error);\n    }\n\n    return Promise.resolve(operationResponse);\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./lib/azureServiceClient.ts","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/node_modules/uuid/index.js\n// module id = 21\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/node_modules/uuid/v1.js\n// module id = 22\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/node_modules/uuid/v4.js\n// module id = 23\n// module chunks = 0","/* eslint-env browser */\nmodule.exports = typeof self == 'object' ? self.FormData : window.FormData;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/form-data/lib/browser.js\n// module id = 24\n// module chunks = 0","(function (self) {\n  'use strict';\n\n  function fetchPonyfill(options) {\n    var Promise = options && options.Promise || self.Promise;\n    var XMLHttpRequest = options && options.XMLHttpRequest || self.XMLHttpRequest;\n    var global = self;\n\n    return (function () {\n      var self = Object.create(global, {\n        fetch: {\n          value: undefined,\n          writable: true\n        }\n      });\n\n      (function(self) {\n        'use strict';\n\n        if (self.fetch) {\n          return\n        }\n\n        var support = {\n          searchParams: 'URLSearchParams' in self,\n          iterable: 'Symbol' in self && 'iterator' in Symbol,\n          blob: 'FileReader' in self && 'Blob' in self && (function() {\n            try {\n              new Blob()\n              return true\n            } catch(e) {\n              return false\n            }\n          })(),\n          formData: 'FormData' in self,\n          arrayBuffer: 'ArrayBuffer' in self\n        }\n\n        if (support.arrayBuffer) {\n          var viewClasses = [\n            '[object Int8Array]',\n            '[object Uint8Array]',\n            '[object Uint8ClampedArray]',\n            '[object Int16Array]',\n            '[object Uint16Array]',\n            '[object Int32Array]',\n            '[object Uint32Array]',\n            '[object Float32Array]',\n            '[object Float64Array]'\n          ]\n\n          var isDataView = function(obj) {\n            return obj && DataView.prototype.isPrototypeOf(obj)\n          }\n\n          var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n          }\n        }\n\n        function normalizeName(name) {\n          if (typeof name !== 'string') {\n            name = String(name)\n          }\n          if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n            throw new TypeError('Invalid character in header field name')\n          }\n          return name.toLowerCase()\n        }\n\n        function normalizeValue(value) {\n          if (typeof value !== 'string') {\n            value = String(value)\n          }\n          return value\n        }\n\n        // Build a destructive iterator for the value list\n        function iteratorFor(items) {\n          var iterator = {\n            next: function() {\n              var value = items.shift()\n              return {done: value === undefined, value: value}\n            }\n          }\n\n          if (support.iterable) {\n            iterator[Symbol.iterator] = function() {\n              return iterator\n            }\n          }\n\n          return iterator\n        }\n\n        function Headers(headers) {\n          this.map = {}\n\n          if (headers instanceof Headers) {\n            headers.forEach(function(value, name) {\n              this.append(name, value)\n            }, this)\n          } else if (Array.isArray(headers)) {\n            headers.forEach(function(header) {\n              this.append(header[0], header[1])\n            }, this)\n          } else if (headers) {\n            Object.getOwnPropertyNames(headers).forEach(function(name) {\n              this.append(name, headers[name])\n            }, this)\n          }\n        }\n\n        Headers.prototype.append = function(name, value) {\n          name = normalizeName(name)\n          value = normalizeValue(value)\n          var oldValue = this.map[name]\n          this.map[name] = oldValue ? oldValue+','+value : value\n        }\n\n        Headers.prototype['delete'] = function(name) {\n          delete this.map[normalizeName(name)]\n        }\n\n        Headers.prototype.get = function(name) {\n          name = normalizeName(name)\n          return this.has(name) ? this.map[name] : null\n        }\n\n        Headers.prototype.has = function(name) {\n          return this.map.hasOwnProperty(normalizeName(name))\n        }\n\n        Headers.prototype.set = function(name, value) {\n          this.map[normalizeName(name)] = normalizeValue(value)\n        }\n\n        Headers.prototype.forEach = function(callback, thisArg) {\n          for (var name in this.map) {\n            if (this.map.hasOwnProperty(name)) {\n              callback.call(thisArg, this.map[name], name, this)\n            }\n          }\n        }\n\n        Headers.prototype.keys = function() {\n          var items = []\n          this.forEach(function(value, name) { items.push(name) })\n          return iteratorFor(items)\n        }\n\n        Headers.prototype.values = function() {\n          var items = []\n          this.forEach(function(value) { items.push(value) })\n          return iteratorFor(items)\n        }\n\n        Headers.prototype.entries = function() {\n          var items = []\n          this.forEach(function(value, name) { items.push([name, value]) })\n          return iteratorFor(items)\n        }\n\n        if (support.iterable) {\n          Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n        }\n\n        function consumed(body) {\n          if (body.bodyUsed) {\n            return Promise.reject(new TypeError('Already read'))\n          }\n          body.bodyUsed = true\n        }\n\n        function fileReaderReady(reader) {\n          return new Promise(function(resolve, reject) {\n            reader.onload = function() {\n              resolve(reader.result)\n            }\n            reader.onerror = function() {\n              reject(reader.error)\n            }\n          })\n        }\n\n        function readBlobAsArrayBuffer(blob) {\n          var reader = new FileReader()\n          var promise = fileReaderReady(reader)\n          reader.readAsArrayBuffer(blob)\n          return promise\n        }\n\n        function readBlobAsText(blob) {\n          var reader = new FileReader()\n          var promise = fileReaderReady(reader)\n          reader.readAsText(blob)\n          return promise\n        }\n\n        function readArrayBufferAsText(buf) {\n          var view = new Uint8Array(buf)\n          var chars = new Array(view.length)\n\n          for (var i = 0; i < view.length; i++) {\n            chars[i] = String.fromCharCode(view[i])\n          }\n          return chars.join('')\n        }\n\n        function bufferClone(buf) {\n          if (buf.slice) {\n            return buf.slice(0)\n          } else {\n            var view = new Uint8Array(buf.byteLength)\n            view.set(new Uint8Array(buf))\n            return view.buffer\n          }\n        }\n\n        function Body() {\n          this.bodyUsed = false\n\n          this._initBody = function(body) {\n            this._bodyInit = body\n            if (!body) {\n              this._bodyText = ''\n            } else if (typeof body === 'string') {\n              this._bodyText = body\n            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n              this._bodyBlob = body\n            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n              this._bodyFormData = body\n            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n              this._bodyText = body.toString()\n            } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n              this._bodyArrayBuffer = bufferClone(body.buffer)\n              // IE 10-11 can't handle a DataView body.\n              this._bodyInit = new Blob([this._bodyArrayBuffer])\n            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n              this._bodyArrayBuffer = bufferClone(body)\n            } else {\n              throw new Error('unsupported BodyInit type')\n            }\n\n            if (!this.headers.get('content-type')) {\n              if (typeof body === 'string') {\n                this.headers.set('content-type', 'text/plain;charset=UTF-8')\n              } else if (this._bodyBlob && this._bodyBlob.type) {\n                this.headers.set('content-type', this._bodyBlob.type)\n              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n              }\n            }\n          }\n\n          if (support.blob) {\n            this.blob = function() {\n              var rejected = consumed(this)\n              if (rejected) {\n                return rejected\n              }\n\n              if (this._bodyBlob) {\n                return Promise.resolve(this._bodyBlob)\n              } else if (this._bodyArrayBuffer) {\n                return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n              } else if (this._bodyFormData) {\n                throw new Error('could not read FormData body as blob')\n              } else {\n                return Promise.resolve(new Blob([this._bodyText]))\n              }\n            }\n\n            this.arrayBuffer = function() {\n              if (this._bodyArrayBuffer) {\n                return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n              } else {\n                return this.blob().then(readBlobAsArrayBuffer)\n              }\n            }\n          }\n\n          this.text = function() {\n            var rejected = consumed(this)\n            if (rejected) {\n              return rejected\n            }\n\n            if (this._bodyBlob) {\n              return readBlobAsText(this._bodyBlob)\n            } else if (this._bodyArrayBuffer) {\n              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n            } else if (this._bodyFormData) {\n              throw new Error('could not read FormData body as text')\n            } else {\n              return Promise.resolve(this._bodyText)\n            }\n          }\n\n          if (support.formData) {\n            this.formData = function() {\n              return this.text().then(decode)\n            }\n          }\n\n          this.json = function() {\n            return this.text().then(JSON.parse)\n          }\n\n          return this\n        }\n\n        // HTTP methods whose capitalization should be normalized\n        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n        function normalizeMethod(method) {\n          var upcased = method.toUpperCase()\n          return (methods.indexOf(upcased) > -1) ? upcased : method\n        }\n\n        function Request(input, options) {\n          options = options || {}\n          var body = options.body\n\n          if (input instanceof Request) {\n            if (input.bodyUsed) {\n              throw new TypeError('Already read')\n            }\n            this.url = input.url\n            this.credentials = input.credentials\n            if (!options.headers) {\n              this.headers = new Headers(input.headers)\n            }\n            this.method = input.method\n            this.mode = input.mode\n            if (!body && input._bodyInit != null) {\n              body = input._bodyInit\n              input.bodyUsed = true\n            }\n          } else {\n            this.url = String(input)\n          }\n\n          this.credentials = options.credentials || this.credentials || 'omit'\n          if (options.headers || !this.headers) {\n            this.headers = new Headers(options.headers)\n          }\n          this.method = normalizeMethod(options.method || this.method || 'GET')\n          this.mode = options.mode || this.mode || null\n          this.referrer = null\n\n          if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n            throw new TypeError('Body not allowed for GET or HEAD requests')\n          }\n          this._initBody(body)\n        }\n\n        Request.prototype.clone = function() {\n          return new Request(this, { body: this._bodyInit })\n        }\n\n        function decode(body) {\n          var form = new FormData()\n          body.trim().split('&').forEach(function(bytes) {\n            if (bytes) {\n              var split = bytes.split('=')\n              var name = split.shift().replace(/\\+/g, ' ')\n              var value = split.join('=').replace(/\\+/g, ' ')\n              form.append(decodeURIComponent(name), decodeURIComponent(value))\n            }\n          })\n          return form\n        }\n\n        function parseHeaders(rawHeaders) {\n          var headers = new Headers()\n          rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n            var parts = line.split(':')\n            var key = parts.shift().trim()\n            if (key) {\n              var value = parts.join(':').trim()\n              headers.append(key, value)\n            }\n          })\n          return headers\n        }\n\n        Body.call(Request.prototype)\n\n        function Response(bodyInit, options) {\n          if (!options) {\n            options = {}\n          }\n\n          this.type = 'default'\n          this.status = 'status' in options ? options.status : 200\n          this.ok = this.status >= 200 && this.status < 300\n          this.statusText = 'statusText' in options ? options.statusText : 'OK'\n          this.headers = new Headers(options.headers)\n          this.url = options.url || ''\n          this._initBody(bodyInit)\n        }\n\n        Body.call(Response.prototype)\n\n        Response.prototype.clone = function() {\n          return new Response(this._bodyInit, {\n            status: this.status,\n            statusText: this.statusText,\n            headers: new Headers(this.headers),\n            url: this.url\n          })\n        }\n\n        Response.error = function() {\n          var response = new Response(null, {status: 0, statusText: ''})\n          response.type = 'error'\n          return response\n        }\n\n        var redirectStatuses = [301, 302, 303, 307, 308]\n\n        Response.redirect = function(url, status) {\n          if (redirectStatuses.indexOf(status) === -1) {\n            throw new RangeError('Invalid status code')\n          }\n\n          return new Response(null, {status: status, headers: {location: url}})\n        }\n\n        self.Headers = Headers\n        self.Request = Request\n        self.Response = Response\n\n        self.fetch = function(input, init) {\n          return new Promise(function(resolve, reject) {\n            var request = new Request(input, init)\n            var xhr = new XMLHttpRequest()\n\n            xhr.onload = function() {\n              var options = {\n                status: xhr.status,\n                statusText: xhr.statusText,\n                headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n              }\n              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n              var body = 'response' in xhr ? xhr.response : xhr.responseText\n              resolve(new Response(body, options))\n            }\n\n            xhr.onerror = function() {\n              reject(new TypeError('Network request failed'))\n            }\n\n            xhr.ontimeout = function() {\n              reject(new TypeError('Network request failed'))\n            }\n\n            xhr.open(request.method, request.url, true)\n\n            if (request.credentials === 'include') {\n              xhr.withCredentials = true\n            }\n\n            if ('responseType' in xhr && support.blob) {\n              xhr.responseType = 'blob'\n            }\n\n            request.headers.forEach(function(value, name) {\n              xhr.setRequestHeader(name, value)\n            })\n\n            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n          })\n        }\n        self.fetch.polyfill = true\n      })(typeof self !== 'undefined' ? self : this);\n\n\n      return {\n        fetch: self.fetch,\n        Headers: self.Headers,\n        Request: self.Request,\n        Response: self.Response\n      };\n    }());\n  }\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return fetchPonyfill;\n    });\n  } else if (typeof exports === 'object') {\n    module.exports = fetchPonyfill;\n  } else {\n    self.fetchPonyfill = fetchPonyfill;\n  }\n}(typeof self === 'undefined' ? this : self));\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/fetch-ponyfill/build/fetch-browser.js\n// module id = 25\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst requestPipeline_1 = require(\"./requestPipeline\");\nconst exponentialRetryPolicyFilter_1 = require(\"./filters/exponentialRetryPolicyFilter\");\nconst systemErrorRetryPolicyFilter_1 = require(\"./filters/systemErrorRetryPolicyFilter\");\nconst redirectFilter_1 = require(\"./filters/redirectFilter\");\nconst signingFilter_1 = require(\"./filters/signingFilter\");\nconst msRestUserAgentFilter_1 = require(\"./filters/msRestUserAgentFilter\");\nconst webResource_1 = require(\"./webResource\");\nconst constants_1 = require(\"./util/constants\");\n/**\n * @class\n * Initializes a new instance of the ServiceClient.\n * @constructor\n * @param {ServiceClientCredentials} [credentials]    - BasicAuthenticationCredentials or\n * TokenCredentials object used for authentication.\n *\n * @param {ServiceClientOptions} [options] The service client options that govern the behavior of the client.\n */\nclass ServiceClient {\n    constructor(credentials, options) {\n        if (!options) {\n            options = {};\n        }\n        if (!options.requestOptions) {\n            options.requestOptions = {};\n        }\n        if (!options.filters) {\n            options.filters = [];\n        }\n        this.userAgentInfo = { value: [] };\n        if (credentials && !credentials.signRequest) {\n            throw new Error('credentials argument needs to implement signRequest method');\n        }\n        try {\n            const moduleName = 'ms-rest';\n            const moduleVersion = constants_1.Constants.msRestVersion;\n            this.addUserAgentInfo(`${moduleName}/${moduleVersion}`);\n        }\n        catch (err) {\n            // do nothing\n        }\n        if (credentials) {\n            options.filters.push(new signingFilter_1.SigningFilter(credentials));\n        }\n        options.filters.push(new msRestUserAgentFilter_1.MsRestUserAgentFilter(this.userAgentInfo.value));\n        options.filters.push(new redirectFilter_1.RedirectFilter());\n        if (!options.noRetryPolicy) {\n            options.filters.push(new exponentialRetryPolicyFilter_1.ExponentialRetryPolicyFilter());\n            options.filters.push(new systemErrorRetryPolicyFilter_1.SystemErrorRetryPolicyFilter());\n        }\n        this.pipeline = new requestPipeline_1.RequestPipeline(options.filters, options.requestOptions).create();\n    }\n    /**\n     * Adds custom information to user agent header\n     * @param {any} additionalUserAgentInfo - information to be added to user agent header, as string.\n     */\n    addUserAgentInfo(additionalUserAgentInfo) {\n        if (this.userAgentInfo.value.indexOf(additionalUserAgentInfo) === -1) {\n            this.userAgentInfo.value.push(additionalUserAgentInfo);\n        }\n        return;\n    }\n    sendRequest(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (options === null || options === undefined || typeof options !== 'object') {\n                throw new Error('options cannot be null or undefined and it must be of type object.');\n            }\n            let httpRequest;\n            try {\n                if (options instanceof webResource_1.WebResource) {\n                    options.validateRequestProperties();\n                    httpRequest = options;\n                }\n                else {\n                    httpRequest = new webResource_1.WebResource();\n                    httpRequest = httpRequest.prepare(options);\n                }\n            }\n            catch (error) {\n                return Promise.reject(error);\n            }\n            // send request\n            let operationResponse;\n            try {\n                operationResponse = yield this.pipeline(httpRequest);\n            }\n            catch (err) {\n                return Promise.reject(err);\n            }\n            return Promise.resolve(operationResponse);\n        });\n    }\n}\nexports.ServiceClient = ServiceClient;\n//# sourceMappingURL=serviceClient.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/serviceClient.js\n// module id = 26\n// module chunks = 0","'use strict';\n\nvar required = require('requires-port')\n  , qs = require('querystringify')\n  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\S\\s]*)/i\n  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//;\n\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\nvar rules = [\n  ['#', 'hash'],                        // Extract from the back.\n  ['?', 'query'],                       // Extract from the back.\n  ['/', 'pathname'],                    // Extract from the back.\n  ['@', 'auth', 1],                     // Extract from the front.\n  [NaN, 'host', undefined, 1, 1],       // Set left over value.\n  [/:(\\d+)$/, 'port', undefined, 1],    // RegExp the back.\n  [NaN, 'hostname', undefined, 1, 1]    // Set left over.\n];\n\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\nvar ignore = { hash: 1, query: 1 };\n\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @api public\n */\nfunction lolcation(loc) {\n  loc = loc || global.location || {};\n\n  var finaldestination = {}\n    , type = typeof loc\n    , key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new URL(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new URL(loc, {});\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @return {ProtocolExtract} Extracted information.\n * @api private\n */\nfunction extractProtocol(address) {\n  var match = protocolre.exec(address);\n\n  return {\n    protocol: match[1] ? match[1].toLowerCase() : '',\n    slashes: !!match[2],\n    rest: match[3]\n  };\n}\n\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @api private\n */\nfunction resolve(relative, base) {\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))\n    , i = path.length\n    , last = path[i - 1]\n    , unshift = false\n    , up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n\n  return path.join('/');\n}\n\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} location Location defaults for relative paths.\n * @param {Boolean|Function} parser Parser for the query string.\n * @api public\n */\nfunction URL(address, location, parser) {\n  if (!(this instanceof URL)) {\n    return new URL(address, location, parser);\n  }\n\n  var relative, extracted, parse, instruction, index, key\n    , instructions = rules.slice()\n    , type = typeof location\n    , url = this\n    , i = 0;\n\n  //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = qs.parse;\n\n  location = lolcation(location);\n\n  //\n  // Extract protocol information before running the instructions.\n  //\n  extracted = extractProtocol(address || '');\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest;\n\n  //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n  if (!extracted.slashes) instructions[2] = [/(.*)/, 'pathname'];\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if ((index = parse.exec(address))) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (\n      relative && instruction[3] ? location[key] || '' : ''\n    );\n\n    //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  }\n\n  //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n  if (parser) url.query = parser(url.query);\n\n  //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n  if (\n      relative\n    && location.slashes\n    && url.pathname.charAt(0) !== '/'\n    && (url.pathname !== '' || location.pathname !== '')\n  ) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  }\n\n  //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n  if (!required(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  }\n\n  //\n  // Parse down the `auth` for the username and password.\n  //\n  url.username = url.password = '';\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  //\n  // The href is just the compiled result.\n  //\n  url.href = url.toString();\n}\n\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL}\n * @api public\n */\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || qs.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!required(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname +':'+ value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n\n      if (url.port) value += ':'+ url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (/:\\d+$/.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n      url.pathname = value.length && value.charAt(0) !== '/' ? '/' + value : value;\n\n      break;\n\n    default:\n      url[part] = value;\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:'\n    ? url.protocol +'//'+ url.host\n    : 'null';\n\n  url.href = url.toString();\n\n  return url;\n}\n\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String}\n * @api public\n */\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;\n\n  var query\n    , url = this\n    , protocol = url.protocol;\n\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n\n  var result = protocol + (url.slashes ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':'+ url.password;\n    result += '@';\n  }\n\n  result += url.host + url.pathname;\n\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;\n\n  if (url.hash) result += url.hash;\n\n  return result;\n}\n\nURL.prototype = { set: set, toString: toString };\n\n//\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\nURL.extractProtocol = extractProtocol;\nURL.location = lolcation;\nURL.qs = qs;\n\nmodule.exports = URL;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/url-parse/index.js\n// module id = 27\n// module chunks = 0","'use strict';\n\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\nmodule.exports = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n    return port !== 80;\n\n    case 'https':\n    case 'wss':\n    return port !== 443;\n\n    case 'ftp':\n    return port !== 21;\n\n    case 'gopher':\n    return port !== 70;\n\n    case 'file':\n    return false;\n  }\n\n  return port !== 0;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/requires-port/index.js\n// module id = 28\n// module chunks = 0","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\n\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String} The decoded string.\n * @api private\n */\nfunction decode(input) {\n  return decodeURIComponent(input.replace(/\\+/g, ' '));\n}\n\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\nfunction querystring(query) {\n  var parser = /([^=?&]+)=?([^&]*)/g\n    , result = {}\n    , part;\n\n  //\n  // Little nifty parsing hack, leverage the fact that RegExp.exec increments\n  // the lastIndex property so we can continue executing this loop until we've\n  // parsed all results.\n  //\n  for (;\n    part = parser.exec(query);\n    result[decode(part[1])] = decode(part[2])\n  );\n\n  return result;\n}\n\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n\n  var pairs = [];\n\n  //\n  // Optionally prefix with a '?' if needed\n  //\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (var key in obj) {\n    if (has.call(obj, key)) {\n      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n}\n\n//\n// Expose the module.\n//\nexports.stringify = querystringify;\nexports.parse = querystring;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/querystringify/index.js\n// module id = 29\n// module chunks = 0","exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/os-browserify/browser.js\n// module id = 30\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst baseFilter_1 = require(\"./baseFilter\");\nclass LogFilter extends baseFilter_1.BaseFilter {\n    constructor(logger = console.log) {\n        super();\n        this.logger = logger;\n    }\n    after(operationResponse) {\n        const self = this;\n        self.logger(`>> Request: ${JSON.stringify(operationResponse.request, undefined, 2)}`);\n        self.logger(`>> Response status code: ${operationResponse.response.status}`);\n        let responseBody = operationResponse.bodyAsText;\n        self.logger(`>> Body: ${responseBody}`);\n        return Promise.resolve(operationResponse);\n    }\n}\nexports.LogFilter = LogFilter;\n//# sourceMappingURL=logFilter.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/filters/logFilter.js\n// module id = 31\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information. \nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = require(\"./util/utils\");\nconst moment_1 = require(\"moment\");\nconst isBuffer = require('is-buffer');\nconst isStream = require(\"is-stream\");\nclass Serializer {\n    constructor(mappers) {\n        this.modelMappers = mappers;\n    }\n    validateConstraints(mapper, value, objectName) {\n        if (mapper.constraints && (value !== null || value !== undefined)) {\n            Object.keys(mapper.constraints).forEach((constraintType) => {\n                if (constraintType.match(/^ExclusiveMaximum$/ig) !== null) {\n                    if (value >= mapper.constraints.ExclusiveMaximum) {\n                        throw new Error(`\"${objectName}\" with value \"${value}\" should satify the constraint \"ExclusiveMaximum\": ${mapper.constraints.ExclusiveMaximum}.`);\n                    }\n                }\n                else if (constraintType.match(/^ExclusiveMinimum$/ig) !== null) {\n                    if (value <= mapper.constraints.ExclusiveMinimum) {\n                        throw new Error(`${objectName} \" with value \"${value} \" should satify the constraint \"ExclusiveMinimum\": ${mapper.constraints.ExclusiveMinimum}.`);\n                    }\n                }\n                else if (constraintType.match(/^InclusiveMaximum$/ig) !== null) {\n                    if (value > mapper.constraints.InclusiveMaximum) {\n                        throw new Error(`${objectName}\" with value \"${value}\" should satify the constraint \"InclusiveMaximum\": ${mapper.constraints.InclusiveMaximum}.`);\n                    }\n                }\n                else if (constraintType.match(/^InclusiveMinimum$/ig) !== null) {\n                    if (value < mapper.constraints.InclusiveMinimum) {\n                        throw new Error(`${objectName}\" with value \"${value}\" should satify the constraint \"InclusiveMinimum\": ${mapper.constraints.InclusiveMinimum}.`);\n                    }\n                }\n                else if (constraintType.match(/^MaxItems$/ig) !== null) {\n                    if (value.length > mapper.constraints.MaxItems) {\n                        throw new Error(`${objectName}\" with value \"${value}\" should satify the constraint \"MaxItems\": ${mapper.constraints.MaxItems}.`);\n                    }\n                }\n                else if (constraintType.match(/^MaxLength$/ig) !== null) {\n                    if (value.length > mapper.constraints.MaxLength) {\n                        throw new Error(`${objectName}\" with value \"${value}\" should satify the constraint \"MaxLength\": ${mapper.constraints.MaxLength}.`);\n                    }\n                }\n                else if (constraintType.match(/^MinItems$/ig) !== null) {\n                    if (value.length < mapper.constraints.MinItems) {\n                        throw new Error(`${objectName}\" with value \"${value}\" should satify the constraint \"MinItems\": ${mapper.constraints.MinItems}.`);\n                    }\n                }\n                else if (constraintType.match(/^MinLength$/ig) !== null) {\n                    if (value.length < mapper.constraints.MinLength) {\n                        throw new Error(`${objectName}\" with value \"${value}\" should satify the constraint \"MinLength\": ${mapper.constraints.MinLength}.`);\n                    }\n                }\n                else if (constraintType.match(/^MultipleOf$/ig) !== null) {\n                    if (value.length % mapper.constraints.MultipleOf !== 0) {\n                        throw new Error(`${objectName}\" with value \"${value}\" should satify the constraint \"MultipleOf\": ${mapper.constraints.MultipleOf}.`);\n                    }\n                }\n                else if (constraintType.match(/^Pattern$/ig) !== null) {\n                    if (value.match(mapper.constraints.Pattern.split('/').join('\\/')) === null) {\n                        throw new Error(`${objectName}\" with value \"${value}\" should satify the constraint \"Pattern\": ${mapper.constraints.Pattern}.`);\n                    }\n                }\n                else if (constraintType.match(/^UniqueItems/ig) !== null) {\n                    if (mapper.constraints.UniqueItems) {\n                        if (value.length !== value.filter((item, i, ar) => { {\n                            return ar.indexOf(item) === i;\n                        } }).length) {\n                            throw new Error(`${objectName}\" with value \"${value}\" should satify the constraint \"UniqueItems\": ${mapper.constraints.UniqueItems}`);\n                        }\n                    }\n                }\n            });\n        }\n    }\n    trimEnd(str, ch) {\n        let len = str.length;\n        while ((len - 1) >= 0 && str[len - 1] === ch) {\n            --len;\n        }\n        return str.substr(0, len);\n    }\n    bufferToBase64Url(buffer) {\n        if (!buffer) {\n            return null;\n        }\n        if (!isBuffer(buffer)) {\n            throw new Error(`Please provide an input of type Buffer for converting to Base64Url.`);\n        }\n        // Buffer to Base64.\n        let str = buffer.toString('base64');\n        // Base64 to Base64Url.\n        return this.trimEnd(str, '=').replace(/\\+/g, '-').replace(/\\//g, '_');\n    }\n    base64UrlToBuffer(str) {\n        if (!str) {\n            return null;\n        }\n        if (str && typeof str.valueOf() !== 'string') {\n            throw new Error('Please provide an input of type string for converting to Buffer');\n        }\n        // Base64Url to Base64.\n        str = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\n        // Base64 to Buffer.\n        return Buffer.from(str, 'base64');\n    }\n    splitSerializeName(prop) {\n        let classes = [];\n        let partialclass = '';\n        let subwords = prop.split('.');\n        subwords.forEach((item) => {\n            if (item.charAt(item.length - 1) === '\\\\') {\n                partialclass += item.substr(0, item.length - 1) + '.';\n            }\n            else {\n                partialclass += item;\n                classes.push(partialclass);\n                partialclass = '';\n            }\n        });\n        return classes;\n    }\n    dateToUnixTime(d) {\n        if (!d) {\n            return null;\n        }\n        if (typeof d.valueOf() === 'string') {\n            d = new Date(d);\n        }\n        return Math.floor(d.getTime() / 1000);\n    }\n    unixTimeToDate(n) {\n        if (!n) {\n            return null;\n        }\n        return new Date(n * 1000);\n    }\n    serializeBasicTypes(typeName, objectName, value) {\n        if (value !== null && value !== undefined) {\n            if (typeName.match(/^Number$/ig) !== null) {\n                if (typeof value !== 'number') {\n                    throw new Error(`${objectName} with value ${value} must be of type number.`);\n                }\n            }\n            else if (typeName.match(/^String$/ig) !== null) {\n                if (typeof value.valueOf() !== 'string') {\n                    throw new Error(`${objectName} with value \"${value}\" must be of type string.`);\n                }\n            }\n            else if (typeName.match(/^Uuid$/ig) !== null) {\n                if (!(typeof value.valueOf() === 'string' && utils.isValidUuid(value))) {\n                    throw new Error(`${objectName} with value \"${value}\" must be of type string and a valid uuid.`);\n                }\n            }\n            else if (typeName.match(/^Boolean$/ig) !== null) {\n                if (typeof value !== 'boolean') {\n                    throw new Error(`${objectName} with value ${value} must be of type boolean.`);\n                }\n            }\n            else if (typeName.match(/^Object$/ig) !== null) {\n                if (typeof value !== 'object') {\n                    throw new Error(`${objectName} must be of type object.`);\n                }\n            }\n            else if (typeName.match(/^Stream$/ig) !== null) {\n                if (!isStream(value)) {\n                    throw new Error(`${objectName} must be of type stream.`);\n                }\n            }\n        }\n        return value;\n    }\n    serializeEnumType(objectName, allowedValues, value) {\n        if (!allowedValues) {\n            throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);\n        }\n        let isPresent = allowedValues.some((item) => {\n            if (typeof item.valueOf() === 'string') {\n                return item.toLowerCase() === value.toLowerCase();\n            }\n            return item === value;\n        });\n        if (!isPresent) {\n            throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);\n        }\n        return value;\n    }\n    serializeBufferType(objectName, value) {\n        if (value !== null && value !== undefined) {\n            if (!isBuffer(value)) {\n                throw new Error(`${objectName} must be of type Buffer.`);\n            }\n            value = value.toString('base64');\n        }\n        return value;\n    }\n    serializeBase64UrlType(objectName, value) {\n        if (value !== null && value !== undefined) {\n            if (!isBuffer(value)) {\n                throw new Error(`${objectName} must be of type Buffer.`);\n            }\n            value = this.bufferToBase64Url(value);\n        }\n        return value;\n    }\n    serializeDateTypes(typeName, value, objectName) {\n        if (value !== null && value !== undefined) {\n            if (typeName.match(/^Date$/ig) !== null) {\n                if (!(value instanceof Date ||\n                    (typeof value.valueOf() === 'string' && !isNaN(Date.parse(value))))) {\n                    throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n                }\n                value = (value instanceof Date) ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);\n            }\n            else if (typeName.match(/^DateTime$/ig) !== null) {\n                if (!(value instanceof Date ||\n                    (typeof value.valueOf() === 'string' && !isNaN(Date.parse(value))))) {\n                    throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);\n                }\n                value = (value instanceof Date) ? value.toISOString() : new Date(value).toISOString();\n            }\n            else if (typeName.match(/^DateTimeRfc1123$/ig) !== null) {\n                if (!(value instanceof Date ||\n                    (typeof value.valueOf() === 'string' && !isNaN(Date.parse(value))))) {\n                    throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);\n                }\n                value = (value instanceof Date) ? value.toUTCString() : new Date(value).toUTCString();\n            }\n            else if (typeName.match(/^UnixTime$/ig) !== null) {\n                if (!(value instanceof Date ||\n                    (typeof value.valueOf() === 'string' && !isNaN(Date.parse(value))))) {\n                    throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +\n                        `for it to be serialized in UnixTime/Epoch format.`);\n                }\n                value = this.dateToUnixTime(value);\n            }\n            else if (typeName.match(/^TimeSpan$/ig) !== null) {\n                if (!moment_1.isDuration(value)) {\n                    throw new Error(`${objectName} must be a TimeSpan/Duration.`);\n                }\n                value = value.toISOString();\n            }\n        }\n        return value;\n    }\n    serializeSequenceType(mapper, object, objectName) {\n        if (!Array.isArray(object)) {\n            throw new Error(`${objectName} must be of type Array.`);\n        }\n        if (!mapper.type.element || typeof mapper.type.element !== 'object') {\n            throw new Error(`element\" metadata for an Array must be defined in the ` +\n                `mapper and it must of type \"object\" in ${objectName}.`);\n        }\n        let tempArray = [];\n        for (let i = 0; i < object.length; i++) {\n            tempArray[i] = this.serialize(mapper.type.element, object[i], objectName);\n        }\n        return tempArray;\n    }\n    serializeDictionaryType(mapper, object, objectName) {\n        if (typeof object !== 'object') {\n            throw new Error(`${objectName} must be of type object.`);\n        }\n        if (!mapper.type.value || typeof mapper.type.value !== 'object') {\n            throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` +\n                `mapper and it must of type \"object\" in ${objectName}.`);\n        }\n        let tempDictionary = {};\n        for (let key in object) {\n            if (object.hasOwnProperty(key)) {\n                tempDictionary[key] = this.serialize(mapper.type.value, object[key], objectName);\n            }\n        }\n        return tempDictionary;\n    }\n    serializeCompositeType(mapper, object, objectName) {\n        //check for polymorphic discriminator\n        if (mapper.type.polymorphicDiscriminator) {\n            mapper = this.getPolymorphicMapper(mapper, object, objectName, 'serialize');\n        }\n        let payload = {};\n        let modelMapper = {\n            required: false,\n            serializedName: 'serializedName',\n            type: {\n                name: 'Composite',\n                className: 'className',\n                modelProperties: {}\n            }\n        };\n        if (object !== null && object !== undefined) {\n            let modelProps = mapper.type.modelProperties;\n            if (!modelProps) {\n                if (!mapper.type.className) {\n                    throw new Error(`Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(mapper, null, 2)}\".`);\n                }\n                //get the mapper if modelProperties of the CompositeType is not present and \n                //then get the modelProperties from it.\n                modelMapper = this.modelMappers[mapper.type.className];\n                if (!modelMapper) {\n                    throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\".`);\n                }\n                modelProps = modelMapper.type.modelProperties;\n                if (!modelProps) {\n                    throw new Error(`modelProperties cannot be null or undefined in the ` +\n                        `mapper \"${JSON.stringify(modelMapper)}\" of type \"${mapper.type.className}\" for object \"${objectName}\".`);\n                }\n            }\n            for (let key in modelProps) {\n                if (modelProps.hasOwnProperty(key)) {\n                    let paths = this.splitSerializeName(modelProps[key].serializedName);\n                    let propName = paths.pop();\n                    let parentObject = payload;\n                    paths.forEach((pathName) => {\n                        let childObject = parentObject[pathName];\n                        if ((childObject === null || childObject === undefined) && (object[key] !== null && object[key] !== undefined)) {\n                            parentObject[pathName] = {};\n                        }\n                        parentObject = parentObject[pathName];\n                    });\n                    //make sure required properties of the CompositeType are present\n                    if (modelProps[key].required && !modelProps[key].isConstant) {\n                        if (object[key] === null || object[key] === undefined) {\n                            throw new Error(`${key}\" cannot be null or undefined in \"${objectName}\".`);\n                        }\n                    }\n                    //make sure that readOnly properties are not sent on the wire\n                    if (modelProps[key].readOnly) {\n                        continue;\n                    }\n                    //serialize the property if it is present in the provided object instance\n                    if (((parentObject !== null && parentObject !== undefined) && (modelProps[key].defaultValue !== null && modelProps[key].defaultValue !== undefined)) ||\n                        (object[key] !== null && object[key] !== undefined)) {\n                        let propertyObjectName = objectName;\n                        if (modelProps[key].serializedName !== '')\n                            propertyObjectName = objectName + '.' + modelProps[key].serializedName;\n                        let propertyMapper = modelProps[key];\n                        let serializedValue = this.serialize(propertyMapper, object[key], propertyObjectName);\n                        if (propName !== null && propName !== undefined)\n                            parentObject[propName] = serializedValue;\n                    }\n                }\n            }\n            return payload;\n        }\n        return object;\n    }\n    /**\n     * Serialize the given object based on its metadata defined in the mapper\n     *\n     * @param {Mapper} mapper The mapper which defines the metadata of the serializable object\n     *\n     * @param {object|string|Array|number|boolean|Date|stream} object A valid Javascript object to be serialized\n     *\n     * @param {string} objectName Name of the serialized object\n     *\n     * @returns {object|string|Array|number|boolean|Date|stream} A valid serialized Javascript object\n     */\n    serialize(mapper, object, objectName) {\n        let payload = {};\n        let mapperType = mapper.type.name;\n        if (!objectName)\n            objectName = mapper.serializedName;\n        if (mapperType.match(/^Sequence$/ig) !== null)\n            payload = [];\n        //Throw if required and object is null or undefined\n        if (mapper.required && (object === null || object === undefined) && !mapper.isConstant) {\n            throw new Error(`${objectName} cannot be null or undefined.`);\n        }\n        //Set Defaults\n        if ((mapper.defaultValue !== null && mapper.defaultValue !== undefined) &&\n            (object === null || object === undefined)) {\n            object = mapper.defaultValue;\n        }\n        if (mapper.isConstant)\n            object = mapper.defaultValue;\n        //Validate Constraints if any\n        this.validateConstraints(mapper, object, objectName);\n        if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/ig) !== null) {\n            payload = this.serializeBasicTypes(mapperType, objectName, object);\n        }\n        else if (mapperType.match(/^Enum$/ig) !== null) {\n            let enumMapper = mapper;\n            payload = this.serializeEnumType(objectName, enumMapper.type.allowedValues, object);\n        }\n        else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/ig) !== null) {\n            payload = this.serializeDateTypes(mapperType, object, objectName);\n        }\n        else if (mapperType.match(/^ByteArray$/ig) !== null) {\n            payload = this.serializeBufferType(objectName, object);\n        }\n        else if (mapperType.match(/^Base64Url$/ig) !== null) {\n            payload = this.serializeBase64UrlType(objectName, object);\n        }\n        else if (mapperType.match(/^Sequence$/ig) !== null) {\n            payload = this.serializeSequenceType(mapper, object, objectName);\n        }\n        else if (mapperType.match(/^Dictionary$/ig) !== null) {\n            payload = this.serializeDictionaryType(mapper, object, objectName);\n        }\n        else if (mapperType.match(/^Composite$/ig) !== null) {\n            payload = this.serializeCompositeType(mapper, object, objectName);\n        }\n        return payload;\n    }\n    deserializeCompositeType(mapper, responseBody, objectName) {\n        /*jshint validthis: true */\n        //check for polymorphic discriminator\n        if (mapper.type.polymorphicDiscriminator) {\n            mapper = this.getPolymorphicMapper(mapper, responseBody, objectName, 'deserialize');\n        }\n        let instance = {};\n        let modelMapper = {\n            required: false,\n            serializedName: 'serializedName',\n            type: {\n                name: 'Composite'\n            }\n        };\n        if (responseBody !== null && responseBody !== undefined) {\n            let modelProps = mapper.type.modelProperties;\n            if (!modelProps) {\n                if (!mapper.type.className) {\n                    throw new Error(`Class name for model \"${objectName}\" is not provided in the mapper \"${JSON.stringify(mapper)}\"`);\n                }\n                //get the mapper if modelProperties of the CompositeType is not present and \n                //then get the modelProperties from it.\n                modelMapper = this.modelMappers[mapper.type.className];\n                if (!modelMapper) {\n                    throw new Error(`mapper() cannot be null or undefined for model \"${mapper.type.className}\"`);\n                }\n                modelProps = modelMapper.type.modelProperties;\n                if (!modelProps) {\n                    throw new Error(`modelProperties cannot be null or undefined in the ` +\n                        `mapper \"${JSON.stringify(modelMapper)}\" of type \"${mapper.type.className}\" for responseBody \"${objectName}\".`);\n                }\n            }\n            for (let key in modelProps) {\n                if (modelProps.hasOwnProperty(key)) {\n                    let jpath = ['responseBody'];\n                    let paths = this.splitSerializeName(modelProps[key].serializedName);\n                    paths.forEach((item) => {\n                        jpath.push(`[\"${item}\"]`);\n                    });\n                    //deserialize the property if it is present in the provided responseBody instance\n                    let propertyInstance;\n                    try {\n                        /*jslint evil: true */\n                        propertyInstance = eval(jpath.join(''));\n                    }\n                    catch (err) {\n                        continue;\n                    }\n                    let propertyObjectName = objectName;\n                    if (modelProps[key].serializedName !== '')\n                        propertyObjectName = objectName + '.' + modelProps[key].serializedName;\n                    let propertyMapper = modelProps[key];\n                    let serializedValue;\n                    //paging\n                    if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === '') {\n                        propertyInstance = responseBody[key];\n                        instance = this.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n                    }\n                    else if (propertyInstance !== null && propertyInstance !== undefined) {\n                        serializedValue = this.deserialize(propertyMapper, propertyInstance, propertyObjectName);\n                        instance[key] = serializedValue;\n                    }\n                }\n            }\n            return instance;\n        }\n        return responseBody;\n    }\n    deserializeDictionaryType(mapper, responseBody, objectName) {\n        /*jshint validthis: true */\n        if (!mapper.type.value || typeof mapper.type.value !== 'object') {\n            throw new Error(`\"value\" metadata for a Dictionary must be defined in the ` +\n                `mapper and it must of type \"object\" in ${objectName}`);\n        }\n        if (responseBody) {\n            let tempDictionary = {};\n            for (let key in responseBody) {\n                if (responseBody.hasOwnProperty(key)) {\n                    tempDictionary[key] = this.deserialize(mapper.type.value, responseBody[key], objectName);\n                }\n            }\n            return tempDictionary;\n        }\n        return responseBody;\n    }\n    deserializeSequenceType(mapper, responseBody, objectName) {\n        /*jshint validthis: true */\n        if (!mapper.type.element || typeof mapper.type.element !== 'object') {\n            throw new Error(`element\" metadata for an Array must be defined in the ` +\n                `mapper and it must of type \"object\" in ${objectName}`);\n        }\n        if (responseBody) {\n            let tempArray = [];\n            for (let i = 0; i < responseBody.length; i++) {\n                tempArray[i] = this.deserialize(mapper.type.element, responseBody[i], objectName);\n            }\n            return tempArray;\n        }\n        return responseBody;\n    }\n    /**\n     * Deserialize the given object based on its metadata defined in the mapper\n     *\n     * @param {object} mapper The mapper which defines the metadata of the serializable object\n     *\n     * @param {object|string|Array|number|boolean|Date|stream} responseBody A valid Javascript entity to be deserialized\n     *\n     * @param {string} objectName Name of the deserialized object\n     *\n     * @returns {object|string|Array|number|boolean|Date|stream} A valid deserialized Javascript object\n     */\n    deserialize(mapper, responseBody, objectName) {\n        if (responseBody === null || responseBody === undefined)\n            return responseBody;\n        let payload;\n        let mapperType = mapper.type.name;\n        if (!objectName)\n            objectName = mapper.serializedName;\n        if (mapperType.match(/^Sequence$/ig) !== null)\n            payload = [];\n        if (mapperType.match(/^(Number|String|Boolean|Enum|Object|Stream|Uuid)$/ig) !== null) {\n            payload = responseBody;\n        }\n        else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/ig) !== null) {\n            payload = new Date(responseBody);\n        }\n        else if (mapperType.match(/^TimeSpan$/ig) !== null) {\n            payload = moment_1.duration(responseBody);\n        }\n        else if (mapperType.match(/^UnixTime$/ig) !== null) {\n            payload = this.unixTimeToDate(responseBody);\n        }\n        else if (mapperType.match(/^ByteArray$/ig) !== null) {\n            payload = Buffer.from(responseBody, 'base64');\n        }\n        else if (mapperType.match(/^Base64Url$/ig) !== null) {\n            payload = this.base64UrlToBuffer(responseBody);\n        }\n        else if (mapperType.match(/^Sequence$/ig) !== null) {\n            payload = this.deserializeSequenceType(mapper, responseBody, objectName);\n        }\n        else if (mapperType.match(/^Dictionary$/ig) !== null) {\n            payload = this.deserializeDictionaryType(mapper, responseBody, objectName);\n        }\n        else if (mapperType.match(/^Composite$/ig) !== null) {\n            payload = this.deserializeCompositeType(mapper, responseBody, objectName);\n        }\n        if (mapper.isConstant)\n            payload = mapper.defaultValue;\n        return payload;\n    }\n    getPolymorphicMapper(mapper, object, objectName, mode) {\n        //check for polymorphic discriminator\n        //Until version 1.15.1, 'polymorphicDiscriminator' in the mapper was a string. This method was not effective when the \n        //polymorphicDiscriminator property had a dot in it's name. So we have comeup with a desgin where polymorphicDiscriminator  \n        //will be an object that contains the clientName (normalized property name, ex: 'odatatype') and \n        //the serializedName (ex: 'odata.type') (We do not escape the dots with double backslash in this case as it is not required). \n        //Thus when serializing, the user will give us an object which will contain the normalizedProperty hence we will lookup\n        //the clientName of the polmorphicDiscriminator in the mapper and during deserialization from the responseBody we will \n        //lookup the serializedName of the polmorphicDiscriminator in the mapper. This will help us in selecting the correct mapper\n        //for the model that needs to be serializes or deserialized. \n        //We need this routing for backwards compatibility. This will absorb the breaking change in the mapper and allow new versions\n        //of the runtime to work seamlessly with older version (>= 0.17.0-Nightly20161008) of Autorest generated node.js clients.\n        if (mapper.type.polymorphicDiscriminator) {\n            if (typeof mapper.type.polymorphicDiscriminator.valueOf() === 'string') {\n                return this.getPolymorphicMapperStringVersion(mapper, object, objectName);\n            }\n            else if (mapper.type.polymorphicDiscriminator instanceof Object) {\n                return this.getPolymorphicMapperObjectVersion(mapper, object, objectName, mode);\n            }\n            else {\n                throw new Error(`The polymorphicDiscriminator for \"${objectName}\" is neither a string nor an object.`);\n            }\n        }\n        return mapper;\n    }\n    //processes new version of the polymorphicDiscriminator in the mapper.\n    getPolymorphicMapperObjectVersion(mapper, object, objectName, mode) {\n        //check for polymorphic discriminator\n        let polymorphicPropertyName = '';\n        if (mode === 'serialize') {\n            polymorphicPropertyName = 'clientName';\n        }\n        else if (mode === 'deserialize') {\n            polymorphicPropertyName = 'serializedName';\n        }\n        else {\n            throw new Error(`The given mode \"${mode}\" for getting the polymorphic mapper for \"${objectName}\" is inavlid.`);\n        }\n        let discriminatorAsObject = mapper.type.polymorphicDiscriminator;\n        if (discriminatorAsObject &&\n            discriminatorAsObject[polymorphicPropertyName] !== null &&\n            discriminatorAsObject[polymorphicPropertyName] !== undefined) {\n            if (object === null || object === undefined) {\n                throw new Error(`${objectName}\" cannot be null or undefined. ` +\n                    `\"${discriminatorAsObject[polymorphicPropertyName]}\" is the ` +\n                    `polmorphicDiscriminator and is a required property.`);\n            }\n            if (object[discriminatorAsObject[polymorphicPropertyName]] === null ||\n                object[discriminatorAsObject[polymorphicPropertyName]] === undefined) {\n                throw new Error(`No discriminator field \"${discriminatorAsObject[polymorphicPropertyName]}\" was found in \"${objectName}\".`);\n            }\n            let indexDiscriminator = null;\n            if (object[discriminatorAsObject[polymorphicPropertyName]] === mapper.type.uberParent) {\n                indexDiscriminator = object[discriminatorAsObject[polymorphicPropertyName]];\n            }\n            else {\n                indexDiscriminator = mapper.type.uberParent + '.' + object[discriminatorAsObject[polymorphicPropertyName]];\n            }\n            if (!this.modelMappers.discriminators[indexDiscriminator]) {\n                throw new Error(`${discriminatorAsObject[polymorphicPropertyName]}\": ` +\n                    `\"${object[discriminatorAsObject[polymorphicPropertyName]]}\" in \"${objectName}\" is not a valid ` +\n                    `discriminator as a corresponding model class for the disciminator \"${indexDiscriminator}\" ` +\n                    `was not found in this.modelMappers.discriminators object.`);\n            }\n            mapper = this.modelMappers.discriminators[indexDiscriminator];\n        }\n        return mapper;\n    }\n    //processes old version of the polymorphicDiscriminator in the mapper.\n    getPolymorphicMapperStringVersion(mapper, object, objectName) {\n        //check for polymorphic discriminator\n        let discriminatorAsString = mapper.type.polymorphicDiscriminator;\n        if (discriminatorAsString !== null && discriminatorAsString !== undefined) {\n            if (object === null || object === undefined) {\n                throw new Error(`${objectName}\" cannot be null or undefined. \"${discriminatorAsString}\" is the ` +\n                    `polmorphicDiscriminator and is a required property.`);\n            }\n            if (object[discriminatorAsString] === null || object[discriminatorAsString] === undefined) {\n                throw new Error(`No discriminator field \"${discriminatorAsString}\" was found in \"${objectName}\".`);\n            }\n            let indexDiscriminator = null;\n            if (object[discriminatorAsString] === mapper.type.uberParent) {\n                indexDiscriminator = object[discriminatorAsString];\n            }\n            else {\n                indexDiscriminator = mapper.type.uberParent + '.' + object[discriminatorAsString];\n            }\n            if (!this.modelMappers.discriminators[indexDiscriminator]) {\n                throw new Error(`${discriminatorAsString}\": ` +\n                    `\"${object[discriminatorAsString]}\"  in \"${objectName}\" is not a valid ` +\n                    `discriminator as a corresponding model class for the disciminator \"${indexDiscriminator}\" ` +\n                    `was not found in this.models.discriminators object.`);\n            }\n            mapper = this.modelMappers.discriminators[indexDiscriminator];\n        }\n        return mapper;\n    }\n}\nexports.Serializer = Serializer;\nfunction serializeObject(toSerialize) {\n    if (toSerialize === null || toSerialize === undefined)\n        return null;\n    if (isBuffer(toSerialize)) {\n        toSerialize = toSerialize.toString('base64');\n        return toSerialize;\n    }\n    else if (toSerialize instanceof Date) {\n        return toSerialize.toISOString();\n    }\n    else if (Array.isArray(toSerialize)) {\n        let array = [];\n        for (let i = 0; i < toSerialize.length; i++) {\n            array.push(serializeObject(toSerialize[i]));\n        }\n        return array;\n    }\n    else if (typeof toSerialize === 'object') {\n        let dictionary = {};\n        for (let property in toSerialize) {\n            dictionary[property] = serializeObject(toSerialize[property]);\n        }\n        return dictionary;\n    }\n    return toSerialize;\n}\nexports.serializeObject = serializeObject;\nexports.MapperType = utils.strEnum([\n    'Base64Url',\n    'Boolean',\n    'ByteArray',\n    'Composite',\n    'Date',\n    'DateTime',\n    'DateTimeRfc1123',\n    'Dictionary',\n    'Enum',\n    'Number',\n    'Object',\n    'Sequence',\n    'String',\n    'Stream',\n    'TimeSpan',\n    'UnixTime'\n]);\n//# sourceMappingURL=serializer.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/serializer.js\n// module id = 32\n// module chunks = 0","//! moment.js\n//! version : 2.18.1\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n\n;(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n    typeof define === 'function' && define.amd ? define(factory) :\n    global.moment = factory()\n}(this, (function () { 'use strict';\n\nvar hookCallback;\n\nfunction hooks () {\n    return hookCallback.apply(null, arguments);\n}\n\n// This is done to register the method called with moment()\n// without creating circular dependencies.\nfunction setHookCallback (callback) {\n    hookCallback = callback;\n}\n\nfunction isArray(input) {\n    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n}\n\nfunction isObject(input) {\n    // IE8 will treat undefined and null as object if it wasn't for\n    // input != null\n    return input != null && Object.prototype.toString.call(input) === '[object Object]';\n}\n\nfunction isObjectEmpty(obj) {\n    var k;\n    for (k in obj) {\n        // even if its not own property I'd still call it non-empty\n        return false;\n    }\n    return true;\n}\n\nfunction isUndefined(input) {\n    return input === void 0;\n}\n\nfunction isNumber(input) {\n    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n}\n\nfunction isDate(input) {\n    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n}\n\nfunction map(arr, fn) {\n    var res = [], i;\n    for (i = 0; i < arr.length; ++i) {\n        res.push(fn(arr[i], i));\n    }\n    return res;\n}\n\nfunction hasOwnProp(a, b) {\n    return Object.prototype.hasOwnProperty.call(a, b);\n}\n\nfunction extend(a, b) {\n    for (var i in b) {\n        if (hasOwnProp(b, i)) {\n            a[i] = b[i];\n        }\n    }\n\n    if (hasOwnProp(b, 'toString')) {\n        a.toString = b.toString;\n    }\n\n    if (hasOwnProp(b, 'valueOf')) {\n        a.valueOf = b.valueOf;\n    }\n\n    return a;\n}\n\nfunction createUTC (input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, true).utc();\n}\n\nfunction defaultParsingFlags() {\n    // We need to deep clone this object.\n    return {\n        empty           : false,\n        unusedTokens    : [],\n        unusedInput     : [],\n        overflow        : -2,\n        charsLeftOver   : 0,\n        nullInput       : false,\n        invalidMonth    : null,\n        invalidFormat   : false,\n        userInvalidated : false,\n        iso             : false,\n        parsedDateParts : [],\n        meridiem        : null,\n        rfc2822         : false,\n        weekdayMismatch : false\n    };\n}\n\nfunction getParsingFlags(m) {\n    if (m._pf == null) {\n        m._pf = defaultParsingFlags();\n    }\n    return m._pf;\n}\n\nvar some;\nif (Array.prototype.some) {\n    some = Array.prototype.some;\n} else {\n    some = function (fun) {\n        var t = Object(this);\n        var len = t.length >>> 0;\n\n        for (var i = 0; i < len; i++) {\n            if (i in t && fun.call(this, t[i], i, t)) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n}\n\nvar some$1 = some;\n\nfunction isValid(m) {\n    if (m._isValid == null) {\n        var flags = getParsingFlags(m);\n        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {\n            return i != null;\n        });\n        var isNowValid = !isNaN(m._d.getTime()) &&\n            flags.overflow < 0 &&\n            !flags.empty &&\n            !flags.invalidMonth &&\n            !flags.invalidWeekday &&\n            !flags.nullInput &&\n            !flags.invalidFormat &&\n            !flags.userInvalidated &&\n            (!flags.meridiem || (flags.meridiem && parsedParts));\n\n        if (m._strict) {\n            isNowValid = isNowValid &&\n                flags.charsLeftOver === 0 &&\n                flags.unusedTokens.length === 0 &&\n                flags.bigHour === undefined;\n        }\n\n        if (Object.isFrozen == null || !Object.isFrozen(m)) {\n            m._isValid = isNowValid;\n        }\n        else {\n            return isNowValid;\n        }\n    }\n    return m._isValid;\n}\n\nfunction createInvalid (flags) {\n    var m = createUTC(NaN);\n    if (flags != null) {\n        extend(getParsingFlags(m), flags);\n    }\n    else {\n        getParsingFlags(m).userInvalidated = true;\n    }\n\n    return m;\n}\n\n// Plugins that add properties should also add the key here (null value),\n// so we can properly clone ourselves.\nvar momentProperties = hooks.momentProperties = [];\n\nfunction copyConfig(to, from) {\n    var i, prop, val;\n\n    if (!isUndefined(from._isAMomentObject)) {\n        to._isAMomentObject = from._isAMomentObject;\n    }\n    if (!isUndefined(from._i)) {\n        to._i = from._i;\n    }\n    if (!isUndefined(from._f)) {\n        to._f = from._f;\n    }\n    if (!isUndefined(from._l)) {\n        to._l = from._l;\n    }\n    if (!isUndefined(from._strict)) {\n        to._strict = from._strict;\n    }\n    if (!isUndefined(from._tzm)) {\n        to._tzm = from._tzm;\n    }\n    if (!isUndefined(from._isUTC)) {\n        to._isUTC = from._isUTC;\n    }\n    if (!isUndefined(from._offset)) {\n        to._offset = from._offset;\n    }\n    if (!isUndefined(from._pf)) {\n        to._pf = getParsingFlags(from);\n    }\n    if (!isUndefined(from._locale)) {\n        to._locale = from._locale;\n    }\n\n    if (momentProperties.length > 0) {\n        for (i = 0; i < momentProperties.length; i++) {\n            prop = momentProperties[i];\n            val = from[prop];\n            if (!isUndefined(val)) {\n                to[prop] = val;\n            }\n        }\n    }\n\n    return to;\n}\n\nvar updateInProgress = false;\n\n// Moment prototype object\nfunction Moment(config) {\n    copyConfig(this, config);\n    this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n    if (!this.isValid()) {\n        this._d = new Date(NaN);\n    }\n    // Prevent infinite loop in case updateOffset creates new moment\n    // objects.\n    if (updateInProgress === false) {\n        updateInProgress = true;\n        hooks.updateOffset(this);\n        updateInProgress = false;\n    }\n}\n\nfunction isMoment (obj) {\n    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);\n}\n\nfunction absFloor (number) {\n    if (number < 0) {\n        // -0 -> 0\n        return Math.ceil(number) || 0;\n    } else {\n        return Math.floor(number);\n    }\n}\n\nfunction toInt(argumentForCoercion) {\n    var coercedNumber = +argumentForCoercion,\n        value = 0;\n\n    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n        value = absFloor(coercedNumber);\n    }\n\n    return value;\n}\n\n// compare two arrays, return the number of differences\nfunction compareArrays(array1, array2, dontConvert) {\n    var len = Math.min(array1.length, array2.length),\n        lengthDiff = Math.abs(array1.length - array2.length),\n        diffs = 0,\n        i;\n    for (i = 0; i < len; i++) {\n        if ((dontConvert && array1[i] !== array2[i]) ||\n            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {\n            diffs++;\n        }\n    }\n    return diffs + lengthDiff;\n}\n\nfunction warn(msg) {\n    if (hooks.suppressDeprecationWarnings === false &&\n            (typeof console !==  'undefined') && console.warn) {\n        console.warn('Deprecation warning: ' + msg);\n    }\n}\n\nfunction deprecate(msg, fn) {\n    var firstTime = true;\n\n    return extend(function () {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(null, msg);\n        }\n        if (firstTime) {\n            var args = [];\n            var arg;\n            for (var i = 0; i < arguments.length; i++) {\n                arg = '';\n                if (typeof arguments[i] === 'object') {\n                    arg += '\\n[' + i + '] ';\n                    for (var key in arguments[0]) {\n                        arg += key + ': ' + arguments[0][key] + ', ';\n                    }\n                    arg = arg.slice(0, -2); // Remove trailing comma and space\n                } else {\n                    arg = arguments[i];\n                }\n                args.push(arg);\n            }\n            warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + (new Error()).stack);\n            firstTime = false;\n        }\n        return fn.apply(this, arguments);\n    }, fn);\n}\n\nvar deprecations = {};\n\nfunction deprecateSimple(name, msg) {\n    if (hooks.deprecationHandler != null) {\n        hooks.deprecationHandler(name, msg);\n    }\n    if (!deprecations[name]) {\n        warn(msg);\n        deprecations[name] = true;\n    }\n}\n\nhooks.suppressDeprecationWarnings = false;\nhooks.deprecationHandler = null;\n\nfunction isFunction(input) {\n    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n}\n\nfunction set (config) {\n    var prop, i;\n    for (i in config) {\n        prop = config[i];\n        if (isFunction(prop)) {\n            this[i] = prop;\n        } else {\n            this['_' + i] = prop;\n        }\n    }\n    this._config = config;\n    // Lenient ordinal parsing accepts just a number in addition to\n    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    this._dayOfMonthOrdinalParseLenient = new RegExp(\n        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +\n            '|' + (/\\d{1,2}/).source);\n}\n\nfunction mergeConfigs(parentConfig, childConfig) {\n    var res = extend({}, parentConfig), prop;\n    for (prop in childConfig) {\n        if (hasOwnProp(childConfig, prop)) {\n            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                res[prop] = {};\n                extend(res[prop], parentConfig[prop]);\n                extend(res[prop], childConfig[prop]);\n            } else if (childConfig[prop] != null) {\n                res[prop] = childConfig[prop];\n            } else {\n                delete res[prop];\n            }\n        }\n    }\n    for (prop in parentConfig) {\n        if (hasOwnProp(parentConfig, prop) &&\n                !hasOwnProp(childConfig, prop) &&\n                isObject(parentConfig[prop])) {\n            // make sure changes to properties don't modify parent config\n            res[prop] = extend({}, res[prop]);\n        }\n    }\n    return res;\n}\n\nfunction Locale(config) {\n    if (config != null) {\n        this.set(config);\n    }\n}\n\nvar keys;\n\nif (Object.keys) {\n    keys = Object.keys;\n} else {\n    keys = function (obj) {\n        var i, res = [];\n        for (i in obj) {\n            if (hasOwnProp(obj, i)) {\n                res.push(i);\n            }\n        }\n        return res;\n    };\n}\n\nvar keys$1 = keys;\n\nvar defaultCalendar = {\n    sameDay : '[Today at] LT',\n    nextDay : '[Tomorrow at] LT',\n    nextWeek : 'dddd [at] LT',\n    lastDay : '[Yesterday at] LT',\n    lastWeek : '[Last] dddd [at] LT',\n    sameElse : 'L'\n};\n\nfunction calendar (key, mom, now) {\n    var output = this._calendar[key] || this._calendar['sameElse'];\n    return isFunction(output) ? output.call(mom, now) : output;\n}\n\nvar defaultLongDateFormat = {\n    LTS  : 'h:mm:ss A',\n    LT   : 'h:mm A',\n    L    : 'MM/DD/YYYY',\n    LL   : 'MMMM D, YYYY',\n    LLL  : 'MMMM D, YYYY h:mm A',\n    LLLL : 'dddd, MMMM D, YYYY h:mm A'\n};\n\nfunction longDateFormat (key) {\n    var format = this._longDateFormat[key],\n        formatUpper = this._longDateFormat[key.toUpperCase()];\n\n    if (format || !formatUpper) {\n        return format;\n    }\n\n    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {\n        return val.slice(1);\n    });\n\n    return this._longDateFormat[key];\n}\n\nvar defaultInvalidDate = 'Invalid date';\n\nfunction invalidDate () {\n    return this._invalidDate;\n}\n\nvar defaultOrdinal = '%d';\nvar defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\nfunction ordinal (number) {\n    return this._ordinal.replace('%d', number);\n}\n\nvar defaultRelativeTime = {\n    future : 'in %s',\n    past   : '%s ago',\n    s  : 'a few seconds',\n    ss : '%d seconds',\n    m  : 'a minute',\n    mm : '%d minutes',\n    h  : 'an hour',\n    hh : '%d hours',\n    d  : 'a day',\n    dd : '%d days',\n    M  : 'a month',\n    MM : '%d months',\n    y  : 'a year',\n    yy : '%d years'\n};\n\nfunction relativeTime (number, withoutSuffix, string, isFuture) {\n    var output = this._relativeTime[string];\n    return (isFunction(output)) ?\n        output(number, withoutSuffix, string, isFuture) :\n        output.replace(/%d/i, number);\n}\n\nfunction pastFuture (diff, output) {\n    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n    return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n}\n\nvar aliases = {};\n\nfunction addUnitAlias (unit, shorthand) {\n    var lowerCase = unit.toLowerCase();\n    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n}\n\nfunction normalizeUnits(units) {\n    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n}\n\nfunction normalizeObjectUnits(inputObject) {\n    var normalizedInput = {},\n        normalizedProp,\n        prop;\n\n    for (prop in inputObject) {\n        if (hasOwnProp(inputObject, prop)) {\n            normalizedProp = normalizeUnits(prop);\n            if (normalizedProp) {\n                normalizedInput[normalizedProp] = inputObject[prop];\n            }\n        }\n    }\n\n    return normalizedInput;\n}\n\nvar priorities = {};\n\nfunction addUnitPriority(unit, priority) {\n    priorities[unit] = priority;\n}\n\nfunction getPrioritizedUnits(unitsObj) {\n    var units = [];\n    for (var u in unitsObj) {\n        units.push({unit: u, priority: priorities[u]});\n    }\n    units.sort(function (a, b) {\n        return a.priority - b.priority;\n    });\n    return units;\n}\n\nfunction makeGetSet (unit, keepTime) {\n    return function (value) {\n        if (value != null) {\n            set$1(this, unit, value);\n            hooks.updateOffset(this, keepTime);\n            return this;\n        } else {\n            return get(this, unit);\n        }\n    };\n}\n\nfunction get (mom, unit) {\n    return mom.isValid() ?\n        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n}\n\nfunction set$1 (mom, unit, value) {\n    if (mom.isValid()) {\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n    }\n}\n\n// MOMENTS\n\nfunction stringGet (units) {\n    units = normalizeUnits(units);\n    if (isFunction(this[units])) {\n        return this[units]();\n    }\n    return this;\n}\n\n\nfunction stringSet (units, value) {\n    if (typeof units === 'object') {\n        units = normalizeObjectUnits(units);\n        var prioritized = getPrioritizedUnits(units);\n        for (var i = 0; i < prioritized.length; i++) {\n            this[prioritized[i].unit](units[prioritized[i].unit]);\n        }\n    } else {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units](value);\n        }\n    }\n    return this;\n}\n\nfunction zeroFill(number, targetLength, forceSign) {\n    var absNumber = '' + Math.abs(number),\n        zerosToFill = targetLength - absNumber.length,\n        sign = number >= 0;\n    return (sign ? (forceSign ? '+' : '') : '-') +\n        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n}\n\nvar formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;\n\nvar localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g;\n\nvar formatFunctions = {};\n\nvar formatTokenFunctions = {};\n\n// token:    'M'\n// padded:   ['MM', 2]\n// ordinal:  'Mo'\n// callback: function () { this.month() + 1 }\nfunction addFormatToken (token, padded, ordinal, callback) {\n    var func = callback;\n    if (typeof callback === 'string') {\n        func = function () {\n            return this[callback]();\n        };\n    }\n    if (token) {\n        formatTokenFunctions[token] = func;\n    }\n    if (padded) {\n        formatTokenFunctions[padded[0]] = function () {\n            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n        };\n    }\n    if (ordinal) {\n        formatTokenFunctions[ordinal] = function () {\n            return this.localeData().ordinal(func.apply(this, arguments), token);\n        };\n    }\n}\n\nfunction removeFormattingTokens(input) {\n    if (input.match(/\\[[\\s\\S]/)) {\n        return input.replace(/^\\[|\\]$/g, '');\n    }\n    return input.replace(/\\\\/g, '');\n}\n\nfunction makeFormatFunction(format) {\n    var array = format.match(formattingTokens), i, length;\n\n    for (i = 0, length = array.length; i < length; i++) {\n        if (formatTokenFunctions[array[i]]) {\n            array[i] = formatTokenFunctions[array[i]];\n        } else {\n            array[i] = removeFormattingTokens(array[i]);\n        }\n    }\n\n    return function (mom) {\n        var output = '', i;\n        for (i = 0; i < length; i++) {\n            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n        }\n        return output;\n    };\n}\n\n// format date using native date object\nfunction formatMoment(m, format) {\n    if (!m.isValid()) {\n        return m.localeData().invalidDate();\n    }\n\n    format = expandFormat(format, m.localeData());\n    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n\n    return formatFunctions[format](m);\n}\n\nfunction expandFormat(format, locale) {\n    var i = 5;\n\n    function replaceLongDateFormatTokens(input) {\n        return locale.longDateFormat(input) || input;\n    }\n\n    localFormattingTokens.lastIndex = 0;\n    while (i >= 0 && localFormattingTokens.test(format)) {\n        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n        localFormattingTokens.lastIndex = 0;\n        i -= 1;\n    }\n\n    return format;\n}\n\nvar match1         = /\\d/;            //       0 - 9\nvar match2         = /\\d\\d/;          //      00 - 99\nvar match3         = /\\d{3}/;         //     000 - 999\nvar match4         = /\\d{4}/;         //    0000 - 9999\nvar match6         = /[+-]?\\d{6}/;    // -999999 - 999999\nvar match1to2      = /\\d\\d?/;         //       0 - 99\nvar match3to4      = /\\d\\d\\d\\d?/;     //     999 - 9999\nvar match5to6      = /\\d\\d\\d\\d\\d\\d?/; //   99999 - 999999\nvar match1to3      = /\\d{1,3}/;       //       0 - 999\nvar match1to4      = /\\d{1,4}/;       //       0 - 9999\nvar match1to6      = /[+-]?\\d{1,6}/;  // -999999 - 999999\n\nvar matchUnsigned  = /\\d+/;           //       0 - inf\nvar matchSigned    = /[+-]?\\d+/;      //    -inf - inf\n\nvar matchOffset    = /Z|[+-]\\d\\d:?\\d\\d/gi; // +00:00 -00:00 +0000 -0000 or Z\nvar matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n\nvar matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/; // 123456789 123456789.123\n\n// any word (or two) characters or numbers including two/three word month in arabic.\n// includes scottish gaelic two word and hyphenated months\nvar matchWord = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\n\n\nvar regexes = {};\n\nfunction addRegexToken (token, regex, strictRegex) {\n    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n        return (isStrict && strictRegex) ? strictRegex : regex;\n    };\n}\n\nfunction getParseRegexForToken (token, config) {\n    if (!hasOwnProp(regexes, token)) {\n        return new RegExp(unescapeFormat(token));\n    }\n\n    return regexes[token](config._strict, config._locale);\n}\n\n// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\nfunction unescapeFormat(s) {\n    return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n        return p1 || p2 || p3 || p4;\n    }));\n}\n\nfunction regexEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nvar tokens = {};\n\nfunction addParseToken (token, callback) {\n    var i, func = callback;\n    if (typeof token === 'string') {\n        token = [token];\n    }\n    if (isNumber(callback)) {\n        func = function (input, array) {\n            array[callback] = toInt(input);\n        };\n    }\n    for (i = 0; i < token.length; i++) {\n        tokens[token[i]] = func;\n    }\n}\n\nfunction addWeekParseToken (token, callback) {\n    addParseToken(token, function (input, array, config, token) {\n        config._w = config._w || {};\n        callback(input, config._w, config, token);\n    });\n}\n\nfunction addTimeToArrayFromToken(token, input, config) {\n    if (input != null && hasOwnProp(tokens, token)) {\n        tokens[token](input, config._a, config, token);\n    }\n}\n\nvar YEAR = 0;\nvar MONTH = 1;\nvar DATE = 2;\nvar HOUR = 3;\nvar MINUTE = 4;\nvar SECOND = 5;\nvar MILLISECOND = 6;\nvar WEEK = 7;\nvar WEEKDAY = 8;\n\nvar indexOf;\n\nif (Array.prototype.indexOf) {\n    indexOf = Array.prototype.indexOf;\n} else {\n    indexOf = function (o) {\n        // I know\n        var i;\n        for (i = 0; i < this.length; ++i) {\n            if (this[i] === o) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\n\nvar indexOf$1 = indexOf;\n\nfunction daysInMonth(year, month) {\n    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();\n}\n\n// FORMATTING\n\naddFormatToken('M', ['MM', 2], 'Mo', function () {\n    return this.month() + 1;\n});\n\naddFormatToken('MMM', 0, 0, function (format) {\n    return this.localeData().monthsShort(this, format);\n});\n\naddFormatToken('MMMM', 0, 0, function (format) {\n    return this.localeData().months(this, format);\n});\n\n// ALIASES\n\naddUnitAlias('month', 'M');\n\n// PRIORITY\n\naddUnitPriority('month', 8);\n\n// PARSING\n\naddRegexToken('M',    match1to2);\naddRegexToken('MM',   match1to2, match2);\naddRegexToken('MMM',  function (isStrict, locale) {\n    return locale.monthsShortRegex(isStrict);\n});\naddRegexToken('MMMM', function (isStrict, locale) {\n    return locale.monthsRegex(isStrict);\n});\n\naddParseToken(['M', 'MM'], function (input, array) {\n    array[MONTH] = toInt(input) - 1;\n});\n\naddParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n    var month = config._locale.monthsParse(input, token, config._strict);\n    // if we didn't find a month name, mark the date as invalid.\n    if (month != null) {\n        array[MONTH] = month;\n    } else {\n        getParsingFlags(config).invalidMonth = input;\n    }\n});\n\n// LOCALES\n\nvar MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/;\nvar defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');\nfunction localeMonths (m, format) {\n    if (!m) {\n        return isArray(this._months) ? this._months :\n            this._months['standalone'];\n    }\n    return isArray(this._months) ? this._months[m.month()] :\n        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n}\n\nvar defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');\nfunction localeMonthsShort (m, format) {\n    if (!m) {\n        return isArray(this._monthsShort) ? this._monthsShort :\n            this._monthsShort['standalone'];\n    }\n    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :\n        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n}\n\nfunction handleStrictParse(monthName, format, strict) {\n    var i, ii, mom, llc = monthName.toLocaleLowerCase();\n    if (!this._monthsParse) {\n        // this is not used\n        this._monthsParse = [];\n        this._longMonthsParse = [];\n        this._shortMonthsParse = [];\n        for (i = 0; i < 12; ++i) {\n            mom = createUTC([2000, i]);\n            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n        }\n    }\n\n    if (strict) {\n        if (format === 'MMM') {\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._longMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    } else {\n        if (format === 'MMM') {\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._longMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._longMonthsParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._shortMonthsParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    }\n}\n\nfunction localeMonthsParse (monthName, format, strict) {\n    var i, mom, regex;\n\n    if (this._monthsParseExact) {\n        return handleStrictParse.call(this, monthName, format, strict);\n    }\n\n    if (!this._monthsParse) {\n        this._monthsParse = [];\n        this._longMonthsParse = [];\n        this._shortMonthsParse = [];\n    }\n\n    // TODO: add sorting\n    // Sorting makes sure if one month (or abbr) is a prefix of another\n    // see sorting in computeMonthsParse\n    for (i = 0; i < 12; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, i]);\n        if (strict && !this._longMonthsParse[i]) {\n            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n        }\n        if (!strict && !this._monthsParse[i]) {\n            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n        }\n        // test the regex\n        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n            return i;\n        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n            return i;\n        } else if (!strict && this._monthsParse[i].test(monthName)) {\n            return i;\n        }\n    }\n}\n\n// MOMENTS\n\nfunction setMonth (mom, value) {\n    var dayOfMonth;\n\n    if (!mom.isValid()) {\n        // No op\n        return mom;\n    }\n\n    if (typeof value === 'string') {\n        if (/^\\d+$/.test(value)) {\n            value = toInt(value);\n        } else {\n            value = mom.localeData().monthsParse(value);\n            // TODO: Another silent failure?\n            if (!isNumber(value)) {\n                return mom;\n            }\n        }\n    }\n\n    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n    return mom;\n}\n\nfunction getSetMonth (value) {\n    if (value != null) {\n        setMonth(this, value);\n        hooks.updateOffset(this, true);\n        return this;\n    } else {\n        return get(this, 'Month');\n    }\n}\n\nfunction getDaysInMonth () {\n    return daysInMonth(this.year(), this.month());\n}\n\nvar defaultMonthsShortRegex = matchWord;\nfunction monthsShortRegex (isStrict) {\n    if (this._monthsParseExact) {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            computeMonthsParse.call(this);\n        }\n        if (isStrict) {\n            return this._monthsShortStrictRegex;\n        } else {\n            return this._monthsShortRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_monthsShortRegex')) {\n            this._monthsShortRegex = defaultMonthsShortRegex;\n        }\n        return this._monthsShortStrictRegex && isStrict ?\n            this._monthsShortStrictRegex : this._monthsShortRegex;\n    }\n}\n\nvar defaultMonthsRegex = matchWord;\nfunction monthsRegex (isStrict) {\n    if (this._monthsParseExact) {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            computeMonthsParse.call(this);\n        }\n        if (isStrict) {\n            return this._monthsStrictRegex;\n        } else {\n            return this._monthsRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_monthsRegex')) {\n            this._monthsRegex = defaultMonthsRegex;\n        }\n        return this._monthsStrictRegex && isStrict ?\n            this._monthsStrictRegex : this._monthsRegex;\n    }\n}\n\nfunction computeMonthsParse () {\n    function cmpLenRev(a, b) {\n        return b.length - a.length;\n    }\n\n    var shortPieces = [], longPieces = [], mixedPieces = [],\n        i, mom;\n    for (i = 0; i < 12; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, i]);\n        shortPieces.push(this.monthsShort(mom, ''));\n        longPieces.push(this.months(mom, ''));\n        mixedPieces.push(this.months(mom, ''));\n        mixedPieces.push(this.monthsShort(mom, ''));\n    }\n    // Sorting makes sure if one month (or abbr) is a prefix of another it\n    // will match the longer piece.\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    for (i = 0; i < 12; i++) {\n        shortPieces[i] = regexEscape(shortPieces[i]);\n        longPieces[i] = regexEscape(longPieces[i]);\n    }\n    for (i = 0; i < 24; i++) {\n        mixedPieces[i] = regexEscape(mixedPieces[i]);\n    }\n\n    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._monthsShortRegex = this._monthsRegex;\n    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n}\n\n// FORMATTING\n\naddFormatToken('Y', 0, 0, function () {\n    var y = this.year();\n    return y <= 9999 ? '' + y : '+' + y;\n});\n\naddFormatToken(0, ['YY', 2], 0, function () {\n    return this.year() % 100;\n});\n\naddFormatToken(0, ['YYYY',   4],       0, 'year');\naddFormatToken(0, ['YYYYY',  5],       0, 'year');\naddFormatToken(0, ['YYYYYY', 6, true], 0, 'year');\n\n// ALIASES\n\naddUnitAlias('year', 'y');\n\n// PRIORITIES\n\naddUnitPriority('year', 1);\n\n// PARSING\n\naddRegexToken('Y',      matchSigned);\naddRegexToken('YY',     match1to2, match2);\naddRegexToken('YYYY',   match1to4, match4);\naddRegexToken('YYYYY',  match1to6, match6);\naddRegexToken('YYYYYY', match1to6, match6);\n\naddParseToken(['YYYYY', 'YYYYYY'], YEAR);\naddParseToken('YYYY', function (input, array) {\n    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n});\naddParseToken('YY', function (input, array) {\n    array[YEAR] = hooks.parseTwoDigitYear(input);\n});\naddParseToken('Y', function (input, array) {\n    array[YEAR] = parseInt(input, 10);\n});\n\n// HELPERS\n\nfunction daysInYear(year) {\n    return isLeapYear(year) ? 366 : 365;\n}\n\nfunction isLeapYear(year) {\n    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;\n}\n\n// HOOKS\n\nhooks.parseTwoDigitYear = function (input) {\n    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n};\n\n// MOMENTS\n\nvar getSetYear = makeGetSet('FullYear', true);\n\nfunction getIsLeapYear () {\n    return isLeapYear(this.year());\n}\n\nfunction createDate (y, m, d, h, M, s, ms) {\n    // can't just apply() to create a date:\n    // https://stackoverflow.com/q/181348\n    var date = new Date(y, m, d, h, M, s, ms);\n\n    // the date constructor remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {\n        date.setFullYear(y);\n    }\n    return date;\n}\n\nfunction createUTCDate (y) {\n    var date = new Date(Date.UTC.apply(null, arguments));\n\n    // the Date.UTC function remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {\n        date.setUTCFullYear(y);\n    }\n    return date;\n}\n\n// start-of-first-week - start-of-year\nfunction firstWeekOffset(year, dow, doy) {\n    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n        fwd = 7 + dow - doy,\n        // first-week day local weekday -- which local weekday is fwd\n        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n\n    return -fwdlw + fwd - 1;\n}\n\n// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\nfunction dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n    var localWeekday = (7 + weekday - dow) % 7,\n        weekOffset = firstWeekOffset(year, dow, doy),\n        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n        resYear, resDayOfYear;\n\n    if (dayOfYear <= 0) {\n        resYear = year - 1;\n        resDayOfYear = daysInYear(resYear) + dayOfYear;\n    } else if (dayOfYear > daysInYear(year)) {\n        resYear = year + 1;\n        resDayOfYear = dayOfYear - daysInYear(year);\n    } else {\n        resYear = year;\n        resDayOfYear = dayOfYear;\n    }\n\n    return {\n        year: resYear,\n        dayOfYear: resDayOfYear\n    };\n}\n\nfunction weekOfYear(mom, dow, doy) {\n    var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n        resWeek, resYear;\n\n    if (week < 1) {\n        resYear = mom.year() - 1;\n        resWeek = week + weeksInYear(resYear, dow, doy);\n    } else if (week > weeksInYear(mom.year(), dow, doy)) {\n        resWeek = week - weeksInYear(mom.year(), dow, doy);\n        resYear = mom.year() + 1;\n    } else {\n        resYear = mom.year();\n        resWeek = week;\n    }\n\n    return {\n        week: resWeek,\n        year: resYear\n    };\n}\n\nfunction weeksInYear(year, dow, doy) {\n    var weekOffset = firstWeekOffset(year, dow, doy),\n        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n}\n\n// FORMATTING\n\naddFormatToken('w', ['ww', 2], 'wo', 'week');\naddFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');\n\n// ALIASES\n\naddUnitAlias('week', 'w');\naddUnitAlias('isoWeek', 'W');\n\n// PRIORITIES\n\naddUnitPriority('week', 5);\naddUnitPriority('isoWeek', 5);\n\n// PARSING\n\naddRegexToken('w',  match1to2);\naddRegexToken('ww', match1to2, match2);\naddRegexToken('W',  match1to2);\naddRegexToken('WW', match1to2, match2);\n\naddWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n    week[token.substr(0, 1)] = toInt(input);\n});\n\n// HELPERS\n\n// LOCALES\n\nfunction localeWeek (mom) {\n    return weekOfYear(mom, this._week.dow, this._week.doy).week;\n}\n\nvar defaultLocaleWeek = {\n    dow : 0, // Sunday is the first day of the week.\n    doy : 6  // The week that contains Jan 1st is the first week of the year.\n};\n\nfunction localeFirstDayOfWeek () {\n    return this._week.dow;\n}\n\nfunction localeFirstDayOfYear () {\n    return this._week.doy;\n}\n\n// MOMENTS\n\nfunction getSetWeek (input) {\n    var week = this.localeData().week(this);\n    return input == null ? week : this.add((input - week) * 7, 'd');\n}\n\nfunction getSetISOWeek (input) {\n    var week = weekOfYear(this, 1, 4).week;\n    return input == null ? week : this.add((input - week) * 7, 'd');\n}\n\n// FORMATTING\n\naddFormatToken('d', 0, 'do', 'day');\n\naddFormatToken('dd', 0, 0, function (format) {\n    return this.localeData().weekdaysMin(this, format);\n});\n\naddFormatToken('ddd', 0, 0, function (format) {\n    return this.localeData().weekdaysShort(this, format);\n});\n\naddFormatToken('dddd', 0, 0, function (format) {\n    return this.localeData().weekdays(this, format);\n});\n\naddFormatToken('e', 0, 0, 'weekday');\naddFormatToken('E', 0, 0, 'isoWeekday');\n\n// ALIASES\n\naddUnitAlias('day', 'd');\naddUnitAlias('weekday', 'e');\naddUnitAlias('isoWeekday', 'E');\n\n// PRIORITY\naddUnitPriority('day', 11);\naddUnitPriority('weekday', 11);\naddUnitPriority('isoWeekday', 11);\n\n// PARSING\n\naddRegexToken('d',    match1to2);\naddRegexToken('e',    match1to2);\naddRegexToken('E',    match1to2);\naddRegexToken('dd',   function (isStrict, locale) {\n    return locale.weekdaysMinRegex(isStrict);\n});\naddRegexToken('ddd',   function (isStrict, locale) {\n    return locale.weekdaysShortRegex(isStrict);\n});\naddRegexToken('dddd',   function (isStrict, locale) {\n    return locale.weekdaysRegex(isStrict);\n});\n\naddWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n    var weekday = config._locale.weekdaysParse(input, token, config._strict);\n    // if we didn't get a weekday name, mark the date as invalid\n    if (weekday != null) {\n        week.d = weekday;\n    } else {\n        getParsingFlags(config).invalidWeekday = input;\n    }\n});\n\naddWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n    week[token] = toInt(input);\n});\n\n// HELPERS\n\nfunction parseWeekday(input, locale) {\n    if (typeof input !== 'string') {\n        return input;\n    }\n\n    if (!isNaN(input)) {\n        return parseInt(input, 10);\n    }\n\n    input = locale.weekdaysParse(input);\n    if (typeof input === 'number') {\n        return input;\n    }\n\n    return null;\n}\n\nfunction parseIsoWeekday(input, locale) {\n    if (typeof input === 'string') {\n        return locale.weekdaysParse(input) % 7 || 7;\n    }\n    return isNaN(input) ? null : input;\n}\n\n// LOCALES\n\nvar defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');\nfunction localeWeekdays (m, format) {\n    if (!m) {\n        return isArray(this._weekdays) ? this._weekdays :\n            this._weekdays['standalone'];\n    }\n    return isArray(this._weekdays) ? this._weekdays[m.day()] :\n        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];\n}\n\nvar defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');\nfunction localeWeekdaysShort (m) {\n    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n}\n\nvar defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');\nfunction localeWeekdaysMin (m) {\n    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n}\n\nfunction handleStrictParse$1(weekdayName, format, strict) {\n    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n    if (!this._weekdaysParse) {\n        this._weekdaysParse = [];\n        this._shortWeekdaysParse = [];\n        this._minWeekdaysParse = [];\n\n        for (i = 0; i < 7; ++i) {\n            mom = createUTC([2000, 1]).day(i);\n            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n        }\n    }\n\n    if (strict) {\n        if (format === 'dddd') {\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else if (format === 'ddd') {\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    } else {\n        if (format === 'dddd') {\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else if (format === 'ddd') {\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        } else {\n            ii = indexOf$1.call(this._minWeekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._weekdaysParse, llc);\n            if (ii !== -1) {\n                return ii;\n            }\n            ii = indexOf$1.call(this._shortWeekdaysParse, llc);\n            return ii !== -1 ? ii : null;\n        }\n    }\n}\n\nfunction localeWeekdaysParse (weekdayName, format, strict) {\n    var i, mom, regex;\n\n    if (this._weekdaysParseExact) {\n        return handleStrictParse$1.call(this, weekdayName, format, strict);\n    }\n\n    if (!this._weekdaysParse) {\n        this._weekdaysParse = [];\n        this._minWeekdaysParse = [];\n        this._shortWeekdaysParse = [];\n        this._fullWeekdaysParse = [];\n    }\n\n    for (i = 0; i < 7; i++) {\n        // make the regex if we don't have it already\n\n        mom = createUTC([2000, 1]).day(i);\n        if (strict && !this._fullWeekdaysParse[i]) {\n            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');\n            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');\n            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');\n        }\n        if (!this._weekdaysParse[i]) {\n            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n        }\n        // test the regex\n        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n            return i;\n        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n            return i;\n        }\n    }\n}\n\n// MOMENTS\n\nfunction getSetDayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n    if (input != null) {\n        input = parseWeekday(input, this.localeData());\n        return this.add(input - day, 'd');\n    } else {\n        return day;\n    }\n}\n\nfunction getSetLocaleDayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n    return input == null ? weekday : this.add(input - weekday, 'd');\n}\n\nfunction getSetISODayOfWeek (input) {\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n\n    // behaves the same as moment#day except\n    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n    // as a setter, sunday should belong to the previous week.\n\n    if (input != null) {\n        var weekday = parseIsoWeekday(input, this.localeData());\n        return this.day(this.day() % 7 ? weekday : weekday - 7);\n    } else {\n        return this.day() || 7;\n    }\n}\n\nvar defaultWeekdaysRegex = matchWord;\nfunction weekdaysRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysStrictRegex;\n        } else {\n            return this._weekdaysRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            this._weekdaysRegex = defaultWeekdaysRegex;\n        }\n        return this._weekdaysStrictRegex && isStrict ?\n            this._weekdaysStrictRegex : this._weekdaysRegex;\n    }\n}\n\nvar defaultWeekdaysShortRegex = matchWord;\nfunction weekdaysShortRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysShortStrictRegex;\n        } else {\n            return this._weekdaysShortRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n            this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n        }\n        return this._weekdaysShortStrictRegex && isStrict ?\n            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n    }\n}\n\nvar defaultWeekdaysMinRegex = matchWord;\nfunction weekdaysMinRegex (isStrict) {\n    if (this._weekdaysParseExact) {\n        if (!hasOwnProp(this, '_weekdaysRegex')) {\n            computeWeekdaysParse.call(this);\n        }\n        if (isStrict) {\n            return this._weekdaysMinStrictRegex;\n        } else {\n            return this._weekdaysMinRegex;\n        }\n    } else {\n        if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n            this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n        }\n        return this._weekdaysMinStrictRegex && isStrict ?\n            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n    }\n}\n\n\nfunction computeWeekdaysParse () {\n    function cmpLenRev(a, b) {\n        return b.length - a.length;\n    }\n\n    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],\n        i, mom, minp, shortp, longp;\n    for (i = 0; i < 7; i++) {\n        // make the regex if we don't have it already\n        mom = createUTC([2000, 1]).day(i);\n        minp = this.weekdaysMin(mom, '');\n        shortp = this.weekdaysShort(mom, '');\n        longp = this.weekdays(mom, '');\n        minPieces.push(minp);\n        shortPieces.push(shortp);\n        longPieces.push(longp);\n        mixedPieces.push(minp);\n        mixedPieces.push(shortp);\n        mixedPieces.push(longp);\n    }\n    // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n    // will match the longer piece.\n    minPieces.sort(cmpLenRev);\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    for (i = 0; i < 7; i++) {\n        shortPieces[i] = regexEscape(shortPieces[i]);\n        longPieces[i] = regexEscape(longPieces[i]);\n        mixedPieces[i] = regexEscape(mixedPieces[i]);\n    }\n\n    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._weekdaysShortRegex = this._weekdaysRegex;\n    this._weekdaysMinRegex = this._weekdaysRegex;\n\n    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n}\n\n// FORMATTING\n\nfunction hFormat() {\n    return this.hours() % 12 || 12;\n}\n\nfunction kFormat() {\n    return this.hours() || 24;\n}\n\naddFormatToken('H', ['HH', 2], 0, 'hour');\naddFormatToken('h', ['hh', 2], 0, hFormat);\naddFormatToken('k', ['kk', 2], 0, kFormat);\n\naddFormatToken('hmm', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n});\n\naddFormatToken('hmmss', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +\n        zeroFill(this.seconds(), 2);\n});\n\naddFormatToken('Hmm', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2);\n});\n\naddFormatToken('Hmmss', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2) +\n        zeroFill(this.seconds(), 2);\n});\n\nfunction meridiem (token, lowercase) {\n    addFormatToken(token, 0, 0, function () {\n        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n    });\n}\n\nmeridiem('a', true);\nmeridiem('A', false);\n\n// ALIASES\n\naddUnitAlias('hour', 'h');\n\n// PRIORITY\naddUnitPriority('hour', 13);\n\n// PARSING\n\nfunction matchMeridiem (isStrict, locale) {\n    return locale._meridiemParse;\n}\n\naddRegexToken('a',  matchMeridiem);\naddRegexToken('A',  matchMeridiem);\naddRegexToken('H',  match1to2);\naddRegexToken('h',  match1to2);\naddRegexToken('k',  match1to2);\naddRegexToken('HH', match1to2, match2);\naddRegexToken('hh', match1to2, match2);\naddRegexToken('kk', match1to2, match2);\n\naddRegexToken('hmm', match3to4);\naddRegexToken('hmmss', match5to6);\naddRegexToken('Hmm', match3to4);\naddRegexToken('Hmmss', match5to6);\n\naddParseToken(['H', 'HH'], HOUR);\naddParseToken(['k', 'kk'], function (input, array, config) {\n    var kInput = toInt(input);\n    array[HOUR] = kInput === 24 ? 0 : kInput;\n});\naddParseToken(['a', 'A'], function (input, array, config) {\n    config._isPm = config._locale.isPM(input);\n    config._meridiem = input;\n});\naddParseToken(['h', 'hh'], function (input, array, config) {\n    array[HOUR] = toInt(input);\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('hmmss', function (input, array, config) {\n    var pos1 = input.length - 4;\n    var pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n    getParsingFlags(config).bigHour = true;\n});\naddParseToken('Hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n});\naddParseToken('Hmmss', function (input, array, config) {\n    var pos1 = input.length - 4;\n    var pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n});\n\n// LOCALES\n\nfunction localeIsPM (input) {\n    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n    // Using charAt should be more compatible.\n    return ((input + '').toLowerCase().charAt(0) === 'p');\n}\n\nvar defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i;\nfunction localeMeridiem (hours, minutes, isLower) {\n    if (hours > 11) {\n        return isLower ? 'pm' : 'PM';\n    } else {\n        return isLower ? 'am' : 'AM';\n    }\n}\n\n\n// MOMENTS\n\n// Setting the hour should keep the time, because the user explicitly\n// specified which hour he wants. So trying to maintain the same hour (in\n// a new timezone) makes sense. Adding/subtracting hours does not follow\n// this rule.\nvar getSetHour = makeGetSet('Hours', true);\n\n// months\n// week\n// weekdays\n// meridiem\nvar baseConfig = {\n    calendar: defaultCalendar,\n    longDateFormat: defaultLongDateFormat,\n    invalidDate: defaultInvalidDate,\n    ordinal: defaultOrdinal,\n    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n    relativeTime: defaultRelativeTime,\n\n    months: defaultLocaleMonths,\n    monthsShort: defaultLocaleMonthsShort,\n\n    week: defaultLocaleWeek,\n\n    weekdays: defaultLocaleWeekdays,\n    weekdaysMin: defaultLocaleWeekdaysMin,\n    weekdaysShort: defaultLocaleWeekdaysShort,\n\n    meridiemParse: defaultLocaleMeridiemParse\n};\n\n// internal storage for locale config files\nvar locales = {};\nvar localeFamilies = {};\nvar globalLocale;\n\nfunction normalizeLocale(key) {\n    return key ? key.toLowerCase().replace('_', '-') : key;\n}\n\n// pick the locale from the array\n// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\nfunction chooseLocale(names) {\n    var i = 0, j, next, locale, split;\n\n    while (i < names.length) {\n        split = normalizeLocale(names[i]).split('-');\n        j = split.length;\n        next = normalizeLocale(names[i + 1]);\n        next = next ? next.split('-') : null;\n        while (j > 0) {\n            locale = loadLocale(split.slice(0, j).join('-'));\n            if (locale) {\n                return locale;\n            }\n            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {\n                //the next array item is better than a shallower substring of this one\n                break;\n            }\n            j--;\n        }\n        i++;\n    }\n    return null;\n}\n\nfunction loadLocale(name) {\n    var oldLocale = null;\n    // TODO: Find a better way to register and load all the locales in Node\n    if (!locales[name] && (typeof module !== 'undefined') &&\n            module && module.exports) {\n        try {\n            oldLocale = globalLocale._abbr;\n            require('./locale/' + name);\n            // because defineLocale currently also sets the global locale, we\n            // want to undo that for lazy loaded locales\n            getSetGlobalLocale(oldLocale);\n        } catch (e) { }\n    }\n    return locales[name];\n}\n\n// This function will load locale and then set the global locale.  If\n// no arguments are passed in, it will simply return the current global\n// locale key.\nfunction getSetGlobalLocale (key, values) {\n    var data;\n    if (key) {\n        if (isUndefined(values)) {\n            data = getLocale(key);\n        }\n        else {\n            data = defineLocale(key, values);\n        }\n\n        if (data) {\n            // moment.duration._locale = moment._locale = data;\n            globalLocale = data;\n        }\n    }\n\n    return globalLocale._abbr;\n}\n\nfunction defineLocale (name, config) {\n    if (config !== null) {\n        var parentConfig = baseConfig;\n        config.abbr = name;\n        if (locales[name] != null) {\n            deprecateSimple('defineLocaleOverride',\n                    'use moment.updateLocale(localeName, config) to change ' +\n                    'an existing locale. moment.defineLocale(localeName, ' +\n                    'config) should only be used for creating a new locale ' +\n                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n            parentConfig = locales[name]._config;\n        } else if (config.parentLocale != null) {\n            if (locales[config.parentLocale] != null) {\n                parentConfig = locales[config.parentLocale]._config;\n            } else {\n                if (!localeFamilies[config.parentLocale]) {\n                    localeFamilies[config.parentLocale] = [];\n                }\n                localeFamilies[config.parentLocale].push({\n                    name: name,\n                    config: config\n                });\n                return null;\n            }\n        }\n        locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n        if (localeFamilies[name]) {\n            localeFamilies[name].forEach(function (x) {\n                defineLocale(x.name, x.config);\n            });\n        }\n\n        // backwards compat for now: also set the locale\n        // make sure we set the locale AFTER all child locales have been\n        // created, so we won't end up with the child locale set.\n        getSetGlobalLocale(name);\n\n\n        return locales[name];\n    } else {\n        // useful for testing\n        delete locales[name];\n        return null;\n    }\n}\n\nfunction updateLocale(name, config) {\n    if (config != null) {\n        var locale, parentConfig = baseConfig;\n        // MERGE\n        if (locales[name] != null) {\n            parentConfig = locales[name]._config;\n        }\n        config = mergeConfigs(parentConfig, config);\n        locale = new Locale(config);\n        locale.parentLocale = locales[name];\n        locales[name] = locale;\n\n        // backwards compat for now: also set the locale\n        getSetGlobalLocale(name);\n    } else {\n        // pass null for config to unupdate, useful for tests\n        if (locales[name] != null) {\n            if (locales[name].parentLocale != null) {\n                locales[name] = locales[name].parentLocale;\n            } else if (locales[name] != null) {\n                delete locales[name];\n            }\n        }\n    }\n    return locales[name];\n}\n\n// returns locale data\nfunction getLocale (key) {\n    var locale;\n\n    if (key && key._locale && key._locale._abbr) {\n        key = key._locale._abbr;\n    }\n\n    if (!key) {\n        return globalLocale;\n    }\n\n    if (!isArray(key)) {\n        //short-circuit everything else\n        locale = loadLocale(key);\n        if (locale) {\n            return locale;\n        }\n        key = [key];\n    }\n\n    return chooseLocale(key);\n}\n\nfunction listLocales() {\n    return keys$1(locales);\n}\n\nfunction checkOverflow (m) {\n    var overflow;\n    var a = m._a;\n\n    if (a && getParsingFlags(m).overflow === -2) {\n        overflow =\n            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :\n            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :\n            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :\n            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :\n            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :\n            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :\n            -1;\n\n        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n            overflow = DATE;\n        }\n        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n            overflow = WEEK;\n        }\n        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n            overflow = WEEKDAY;\n        }\n\n        getParsingFlags(m).overflow = overflow;\n    }\n\n    return m;\n}\n\n// iso 8601 regex\n// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\nvar extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\nvar basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([\\+\\-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/;\n\nvar tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/;\n\nvar isoDates = [\n    ['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/],\n    ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/],\n    ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/],\n    ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false],\n    ['YYYY-DDD', /\\d{4}-\\d{3}/],\n    ['YYYY-MM', /\\d{4}-\\d\\d/, false],\n    ['YYYYYYMMDD', /[+-]\\d{10}/],\n    ['YYYYMMDD', /\\d{8}/],\n    // YYYYMM is NOT allowed by the standard\n    ['GGGG[W]WWE', /\\d{4}W\\d{3}/],\n    ['GGGG[W]WW', /\\d{4}W\\d{2}/, false],\n    ['YYYYDDD', /\\d{7}/]\n];\n\n// iso time formats and regexes\nvar isoTimes = [\n    ['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/],\n    ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/],\n    ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/],\n    ['HH:mm', /\\d\\d:\\d\\d/],\n    ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/],\n    ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/],\n    ['HHmmss', /\\d\\d\\d\\d\\d\\d/],\n    ['HHmm', /\\d\\d\\d\\d/],\n    ['HH', /\\d\\d/]\n];\n\nvar aspNetJsonRegex = /^\\/?Date\\((\\-?\\d+)/i;\n\n// date from iso format\nfunction configFromISO(config) {\n    var i, l,\n        string = config._i,\n        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n        allowTime, dateFormat, timeFormat, tzFormat;\n\n    if (match) {\n        getParsingFlags(config).iso = true;\n\n        for (i = 0, l = isoDates.length; i < l; i++) {\n            if (isoDates[i][1].exec(match[1])) {\n                dateFormat = isoDates[i][0];\n                allowTime = isoDates[i][2] !== false;\n                break;\n            }\n        }\n        if (dateFormat == null) {\n            config._isValid = false;\n            return;\n        }\n        if (match[3]) {\n            for (i = 0, l = isoTimes.length; i < l; i++) {\n                if (isoTimes[i][1].exec(match[3])) {\n                    // match[2] should be 'T' or space\n                    timeFormat = (match[2] || ' ') + isoTimes[i][0];\n                    break;\n                }\n            }\n            if (timeFormat == null) {\n                config._isValid = false;\n                return;\n            }\n        }\n        if (!allowTime && timeFormat != null) {\n            config._isValid = false;\n            return;\n        }\n        if (match[4]) {\n            if (tzRegex.exec(match[4])) {\n                tzFormat = 'Z';\n            } else {\n                config._isValid = false;\n                return;\n            }\n        }\n        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n        configFromStringAndFormat(config);\n    } else {\n        config._isValid = false;\n    }\n}\n\n// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\nvar basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d?\\d\\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(?:\\d\\d)?\\d\\d\\s)(\\d\\d:\\d\\d)(\\:\\d\\d)?(\\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\\d{4}))$/;\n\n// date and time from ref 2822 format\nfunction configFromRFC2822(config) {\n    var string, match, dayFormat,\n        dateFormat, timeFormat, tzFormat;\n    var timezones = {\n        ' GMT': ' +0000',\n        ' EDT': ' -0400',\n        ' EST': ' -0500',\n        ' CDT': ' -0500',\n        ' CST': ' -0600',\n        ' MDT': ' -0600',\n        ' MST': ' -0700',\n        ' PDT': ' -0700',\n        ' PST': ' -0800'\n    };\n    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';\n    var timezone, timezoneIndex;\n\n    string = config._i\n        .replace(/\\([^\\)]*\\)|[\\n\\t]/g, ' ') // Remove comments and folding whitespace\n        .replace(/(\\s\\s+)/g, ' ') // Replace multiple-spaces with a single space\n        .replace(/^\\s|\\s$/g, ''); // Remove leading and trailing spaces\n    match = basicRfcRegex.exec(string);\n\n    if (match) {\n        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';\n        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');\n        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');\n\n        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.\n        if (match[1]) { // day of week given\n            var momentDate = new Date(match[2]);\n            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];\n\n            if (match[1].substr(0,3) !== momentDay) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return;\n            }\n        }\n\n        switch (match[5].length) {\n            case 2: // military\n                if (timezoneIndex === 0) {\n                    timezone = ' +0000';\n                } else {\n                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;\n                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +\n                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';\n                }\n                break;\n            case 4: // Zone\n                timezone = timezones[match[5]];\n                break;\n            default: // UT or +/-9999\n                timezone = timezones[' GMT'];\n        }\n        match[5] = timezone;\n        config._i = match.splice(1).join('');\n        tzFormat = ' ZZ';\n        config._f = dayFormat + dateFormat + timeFormat + tzFormat;\n        configFromStringAndFormat(config);\n        getParsingFlags(config).rfc2822 = true;\n    } else {\n        config._isValid = false;\n    }\n}\n\n// date from iso format or fallback\nfunction configFromString(config) {\n    var matched = aspNetJsonRegex.exec(config._i);\n\n    if (matched !== null) {\n        config._d = new Date(+matched[1]);\n        return;\n    }\n\n    configFromISO(config);\n    if (config._isValid === false) {\n        delete config._isValid;\n    } else {\n        return;\n    }\n\n    configFromRFC2822(config);\n    if (config._isValid === false) {\n        delete config._isValid;\n    } else {\n        return;\n    }\n\n    // Final attempt, use Input Fallback\n    hooks.createFromInputFallback(config);\n}\n\nhooks.createFromInputFallback = deprecate(\n    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +\n    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +\n    'discouraged and will be removed in an upcoming major release. Please refer to ' +\n    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',\n    function (config) {\n        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n    }\n);\n\n// Pick the first defined of two or three arguments.\nfunction defaults(a, b, c) {\n    if (a != null) {\n        return a;\n    }\n    if (b != null) {\n        return b;\n    }\n    return c;\n}\n\nfunction currentDateArray(config) {\n    // hooks is actually the exported moment object\n    var nowValue = new Date(hooks.now());\n    if (config._useUTC) {\n        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n    }\n    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n}\n\n// convert an array to a date.\n// the array should mirror the parameters below\n// note: all values past the year are optional and will default to the lowest possible value.\n// [year, month, day , hour, minute, second, millisecond]\nfunction configFromArray (config) {\n    var i, date, input = [], currentDate, yearToUse;\n\n    if (config._d) {\n        return;\n    }\n\n    currentDate = currentDateArray(config);\n\n    //compute day of the year from weeks and weekdays\n    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n        dayOfYearFromWeekInfo(config);\n    }\n\n    //if the day of the year is set, figure out what it is\n    if (config._dayOfYear != null) {\n        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n            getParsingFlags(config)._overflowDayOfYear = true;\n        }\n\n        date = createUTCDate(yearToUse, 0, config._dayOfYear);\n        config._a[MONTH] = date.getUTCMonth();\n        config._a[DATE] = date.getUTCDate();\n    }\n\n    // Default to current date.\n    // * if no year, month, day of month are given, default to today\n    // * if day of month is given, default month and year\n    // * if month is given, default only year\n    // * if year is given, don't default anything\n    for (i = 0; i < 3 && config._a[i] == null; ++i) {\n        config._a[i] = input[i] = currentDate[i];\n    }\n\n    // Zero out whatever was not defaulted, including time\n    for (; i < 7; i++) {\n        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];\n    }\n\n    // Check for 24:00:00.000\n    if (config._a[HOUR] === 24 &&\n            config._a[MINUTE] === 0 &&\n            config._a[SECOND] === 0 &&\n            config._a[MILLISECOND] === 0) {\n        config._nextDay = true;\n        config._a[HOUR] = 0;\n    }\n\n    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n    // Apply timezone offset from input. The actual utcOffset can be changed\n    // with parseZone.\n    if (config._tzm != null) {\n        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n    }\n\n    if (config._nextDay) {\n        config._a[HOUR] = 24;\n    }\n}\n\nfunction dayOfYearFromWeekInfo(config) {\n    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;\n\n    w = config._w;\n    if (w.GG != null || w.W != null || w.E != null) {\n        dow = 1;\n        doy = 4;\n\n        // TODO: We need to take the current isoWeekYear, but that depends on\n        // how we interpret now (local, utc, fixed offset). So create\n        // a now version of current config (take local/utc/offset flags, and\n        // create now).\n        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n        week = defaults(w.W, 1);\n        weekday = defaults(w.E, 1);\n        if (weekday < 1 || weekday > 7) {\n            weekdayOverflow = true;\n        }\n    } else {\n        dow = config._locale._week.dow;\n        doy = config._locale._week.doy;\n\n        var curWeek = weekOfYear(createLocal(), dow, doy);\n\n        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n\n        // Default to current week.\n        week = defaults(w.w, curWeek.week);\n\n        if (w.d != null) {\n            // weekday -- low day numbers are considered next week\n            weekday = w.d;\n            if (weekday < 0 || weekday > 6) {\n                weekdayOverflow = true;\n            }\n        } else if (w.e != null) {\n            // local weekday -- counting starts from begining of week\n            weekday = w.e + dow;\n            if (w.e < 0 || w.e > 6) {\n                weekdayOverflow = true;\n            }\n        } else {\n            // default to begining of week\n            weekday = dow;\n        }\n    }\n    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n        getParsingFlags(config)._overflowWeeks = true;\n    } else if (weekdayOverflow != null) {\n        getParsingFlags(config)._overflowWeekday = true;\n    } else {\n        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n        config._a[YEAR] = temp.year;\n        config._dayOfYear = temp.dayOfYear;\n    }\n}\n\n// constant that refers to the ISO standard\nhooks.ISO_8601 = function () {};\n\n// constant that refers to the RFC 2822 form\nhooks.RFC_2822 = function () {};\n\n// date from string and format string\nfunction configFromStringAndFormat(config) {\n    // TODO: Move this to another part of the creation flow to prevent circular deps\n    if (config._f === hooks.ISO_8601) {\n        configFromISO(config);\n        return;\n    }\n    if (config._f === hooks.RFC_2822) {\n        configFromRFC2822(config);\n        return;\n    }\n    config._a = [];\n    getParsingFlags(config).empty = true;\n\n    // This array is used to make a Date, either with `new Date` or `Date.UTC`\n    var string = '' + config._i,\n        i, parsedInput, tokens, token, skipped,\n        stringLength = string.length,\n        totalParsedInputLength = 0;\n\n    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n\n    for (i = 0; i < tokens.length; i++) {\n        token = tokens[i];\n        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n        // console.log('token', token, 'parsedInput', parsedInput,\n        //         'regex', getParseRegexForToken(token, config));\n        if (parsedInput) {\n            skipped = string.substr(0, string.indexOf(parsedInput));\n            if (skipped.length > 0) {\n                getParsingFlags(config).unusedInput.push(skipped);\n            }\n            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n            totalParsedInputLength += parsedInput.length;\n        }\n        // don't parse if it's not a known token\n        if (formatTokenFunctions[token]) {\n            if (parsedInput) {\n                getParsingFlags(config).empty = false;\n            }\n            else {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n            addTimeToArrayFromToken(token, parsedInput, config);\n        }\n        else if (config._strict && !parsedInput) {\n            getParsingFlags(config).unusedTokens.push(token);\n        }\n    }\n\n    // add remaining unparsed input length to the string\n    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n    if (string.length > 0) {\n        getParsingFlags(config).unusedInput.push(string);\n    }\n\n    // clear _12h flag if hour is <= 12\n    if (config._a[HOUR] <= 12 &&\n        getParsingFlags(config).bigHour === true &&\n        config._a[HOUR] > 0) {\n        getParsingFlags(config).bigHour = undefined;\n    }\n\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\n    getParsingFlags(config).meridiem = config._meridiem;\n    // handle meridiem\n    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n\n    configFromArray(config);\n    checkOverflow(config);\n}\n\n\nfunction meridiemFixWrap (locale, hour, meridiem) {\n    var isPm;\n\n    if (meridiem == null) {\n        // nothing to do\n        return hour;\n    }\n    if (locale.meridiemHour != null) {\n        return locale.meridiemHour(hour, meridiem);\n    } else if (locale.isPM != null) {\n        // Fallback\n        isPm = locale.isPM(meridiem);\n        if (isPm && hour < 12) {\n            hour += 12;\n        }\n        if (!isPm && hour === 12) {\n            hour = 0;\n        }\n        return hour;\n    } else {\n        // this is not supposed to happen\n        return hour;\n    }\n}\n\n// date from string and array of format strings\nfunction configFromStringAndArray(config) {\n    var tempConfig,\n        bestMoment,\n\n        scoreToBeat,\n        i,\n        currentScore;\n\n    if (config._f.length === 0) {\n        getParsingFlags(config).invalidFormat = true;\n        config._d = new Date(NaN);\n        return;\n    }\n\n    for (i = 0; i < config._f.length; i++) {\n        currentScore = 0;\n        tempConfig = copyConfig({}, config);\n        if (config._useUTC != null) {\n            tempConfig._useUTC = config._useUTC;\n        }\n        tempConfig._f = config._f[i];\n        configFromStringAndFormat(tempConfig);\n\n        if (!isValid(tempConfig)) {\n            continue;\n        }\n\n        // if there is any input that was not parsed add a penalty for that format\n        currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n        //or tokens\n        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n        getParsingFlags(tempConfig).score = currentScore;\n\n        if (scoreToBeat == null || currentScore < scoreToBeat) {\n            scoreToBeat = currentScore;\n            bestMoment = tempConfig;\n        }\n    }\n\n    extend(config, bestMoment || tempConfig);\n}\n\nfunction configFromObject(config) {\n    if (config._d) {\n        return;\n    }\n\n    var i = normalizeObjectUnits(config._i);\n    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n        return obj && parseInt(obj, 10);\n    });\n\n    configFromArray(config);\n}\n\nfunction createFromConfig (config) {\n    var res = new Moment(checkOverflow(prepareConfig(config)));\n    if (res._nextDay) {\n        // Adding is smart enough around DST\n        res.add(1, 'd');\n        res._nextDay = undefined;\n    }\n\n    return res;\n}\n\nfunction prepareConfig (config) {\n    var input = config._i,\n        format = config._f;\n\n    config._locale = config._locale || getLocale(config._l);\n\n    if (input === null || (format === undefined && input === '')) {\n        return createInvalid({nullInput: true});\n    }\n\n    if (typeof input === 'string') {\n        config._i = input = config._locale.preparse(input);\n    }\n\n    if (isMoment(input)) {\n        return new Moment(checkOverflow(input));\n    } else if (isDate(input)) {\n        config._d = input;\n    } else if (isArray(format)) {\n        configFromStringAndArray(config);\n    } else if (format) {\n        configFromStringAndFormat(config);\n    }  else {\n        configFromInput(config);\n    }\n\n    if (!isValid(config)) {\n        config._d = null;\n    }\n\n    return config;\n}\n\nfunction configFromInput(config) {\n    var input = config._i;\n    if (isUndefined(input)) {\n        config._d = new Date(hooks.now());\n    } else if (isDate(input)) {\n        config._d = new Date(input.valueOf());\n    } else if (typeof input === 'string') {\n        configFromString(config);\n    } else if (isArray(input)) {\n        config._a = map(input.slice(0), function (obj) {\n            return parseInt(obj, 10);\n        });\n        configFromArray(config);\n    } else if (isObject(input)) {\n        configFromObject(config);\n    } else if (isNumber(input)) {\n        // from milliseconds\n        config._d = new Date(input);\n    } else {\n        hooks.createFromInputFallback(config);\n    }\n}\n\nfunction createLocalOrUTC (input, format, locale, strict, isUTC) {\n    var c = {};\n\n    if (locale === true || locale === false) {\n        strict = locale;\n        locale = undefined;\n    }\n\n    if ((isObject(input) && isObjectEmpty(input)) ||\n            (isArray(input) && input.length === 0)) {\n        input = undefined;\n    }\n    // object construction must be done this way.\n    // https://github.com/moment/moment/issues/1423\n    c._isAMomentObject = true;\n    c._useUTC = c._isUTC = isUTC;\n    c._l = locale;\n    c._i = input;\n    c._f = format;\n    c._strict = strict;\n\n    return createFromConfig(c);\n}\n\nfunction createLocal (input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, false);\n}\n\nvar prototypeMin = deprecate(\n    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',\n    function () {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other < this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    }\n);\n\nvar prototypeMax = deprecate(\n    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',\n    function () {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other > this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    }\n);\n\n// Pick a moment m from moments so that m[fn](other) is true for all\n// other. This relies on the function fn to be transitive.\n//\n// moments should either be an array of moment objects or an array, whose\n// first element is an array of moment objects.\nfunction pickBy(fn, moments) {\n    var res, i;\n    if (moments.length === 1 && isArray(moments[0])) {\n        moments = moments[0];\n    }\n    if (!moments.length) {\n        return createLocal();\n    }\n    res = moments[0];\n    for (i = 1; i < moments.length; ++i) {\n        if (!moments[i].isValid() || moments[i][fn](res)) {\n            res = moments[i];\n        }\n    }\n    return res;\n}\n\n// TODO: Use [].sort instead?\nfunction min () {\n    var args = [].slice.call(arguments, 0);\n\n    return pickBy('isBefore', args);\n}\n\nfunction max () {\n    var args = [].slice.call(arguments, 0);\n\n    return pickBy('isAfter', args);\n}\n\nvar now = function () {\n    return Date.now ? Date.now() : +(new Date());\n};\n\nvar ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\nfunction isDurationValid(m) {\n    for (var key in m) {\n        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n            return false;\n        }\n    }\n\n    var unitHasDecimal = false;\n    for (var i = 0; i < ordering.length; ++i) {\n        if (m[ordering[i]]) {\n            if (unitHasDecimal) {\n                return false; // only allow non-integers for smallest unit\n            }\n            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                unitHasDecimal = true;\n            }\n        }\n    }\n\n    return true;\n}\n\nfunction isValid$1() {\n    return this._isValid;\n}\n\nfunction createInvalid$1() {\n    return createDuration(NaN);\n}\n\nfunction Duration (duration) {\n    var normalizedInput = normalizeObjectUnits(duration),\n        years = normalizedInput.year || 0,\n        quarters = normalizedInput.quarter || 0,\n        months = normalizedInput.month || 0,\n        weeks = normalizedInput.week || 0,\n        days = normalizedInput.day || 0,\n        hours = normalizedInput.hour || 0,\n        minutes = normalizedInput.minute || 0,\n        seconds = normalizedInput.second || 0,\n        milliseconds = normalizedInput.millisecond || 0;\n\n    this._isValid = isDurationValid(normalizedInput);\n\n    // representation for dateAddRemove\n    this._milliseconds = +milliseconds +\n        seconds * 1e3 + // 1000\n        minutes * 6e4 + // 1000 * 60\n        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n    // Because of dateAddRemove treats 24 hours as different from a\n    // day when working around DST, we need to store them separately\n    this._days = +days +\n        weeks * 7;\n    // It is impossible translate months into days without knowing\n    // which months you are are talking about, so we have to store\n    // it separately.\n    this._months = +months +\n        quarters * 3 +\n        years * 12;\n\n    this._data = {};\n\n    this._locale = getLocale();\n\n    this._bubble();\n}\n\nfunction isDuration (obj) {\n    return obj instanceof Duration;\n}\n\nfunction absRound (number) {\n    if (number < 0) {\n        return Math.round(-1 * number) * -1;\n    } else {\n        return Math.round(number);\n    }\n}\n\n// FORMATTING\n\nfunction offset (token, separator) {\n    addFormatToken(token, 0, 0, function () {\n        var offset = this.utcOffset();\n        var sign = '+';\n        if (offset < 0) {\n            offset = -offset;\n            sign = '-';\n        }\n        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);\n    });\n}\n\noffset('Z', ':');\noffset('ZZ', '');\n\n// PARSING\n\naddRegexToken('Z',  matchShortOffset);\naddRegexToken('ZZ', matchShortOffset);\naddParseToken(['Z', 'ZZ'], function (input, array, config) {\n    config._useUTC = true;\n    config._tzm = offsetFromString(matchShortOffset, input);\n});\n\n// HELPERS\n\n// timezone chunker\n// '+10:00' > ['10',  '00']\n// '-1530'  > ['-15', '30']\nvar chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\nfunction offsetFromString(matcher, string) {\n    var matches = (string || '').match(matcher);\n\n    if (matches === null) {\n        return null;\n    }\n\n    var chunk   = matches[matches.length - 1] || [];\n    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n    var minutes = +(parts[1] * 60) + toInt(parts[2]);\n\n    return minutes === 0 ?\n      0 :\n      parts[0] === '+' ? minutes : -minutes;\n}\n\n// Return a moment from input, that is local/utc/zone equivalent to model.\nfunction cloneWithOffset(input, model) {\n    var res, diff;\n    if (model._isUTC) {\n        res = model.clone();\n        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n        // Use low-level api, because this fn is low-level api.\n        res._d.setTime(res._d.valueOf() + diff);\n        hooks.updateOffset(res, false);\n        return res;\n    } else {\n        return createLocal(input).local();\n    }\n}\n\nfunction getDateOffset (m) {\n    // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n    // https://github.com/moment/moment/pull/1871\n    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;\n}\n\n// HOOKS\n\n// This function will be called whenever a moment is mutated.\n// It is intended to keep the offset in sync with the timezone.\nhooks.updateOffset = function () {};\n\n// MOMENTS\n\n// keepLocalTime = true means only change the timezone, without\n// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n// +0200, so we adjust the time as needed, to be valid.\n//\n// Keeping the time actually adds/subtracts (one hour)\n// from the actual represented time. That is why we call updateOffset\n// a second time. In case it wants us to change the offset again\n// _changeInProgress == true case, then we have to adjust, because\n// there is no such time in the given timezone.\nfunction getSetOffset (input, keepLocalTime, keepMinutes) {\n    var offset = this._offset || 0,\n        localAdjust;\n    if (!this.isValid()) {\n        return input != null ? this : NaN;\n    }\n    if (input != null) {\n        if (typeof input === 'string') {\n            input = offsetFromString(matchShortOffset, input);\n            if (input === null) {\n                return this;\n            }\n        } else if (Math.abs(input) < 16 && !keepMinutes) {\n            input = input * 60;\n        }\n        if (!this._isUTC && keepLocalTime) {\n            localAdjust = getDateOffset(this);\n        }\n        this._offset = input;\n        this._isUTC = true;\n        if (localAdjust != null) {\n            this.add(localAdjust, 'm');\n        }\n        if (offset !== input) {\n            if (!keepLocalTime || this._changeInProgress) {\n                addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n            } else if (!this._changeInProgress) {\n                this._changeInProgress = true;\n                hooks.updateOffset(this, true);\n                this._changeInProgress = null;\n            }\n        }\n        return this;\n    } else {\n        return this._isUTC ? offset : getDateOffset(this);\n    }\n}\n\nfunction getSetZone (input, keepLocalTime) {\n    if (input != null) {\n        if (typeof input !== 'string') {\n            input = -input;\n        }\n\n        this.utcOffset(input, keepLocalTime);\n\n        return this;\n    } else {\n        return -this.utcOffset();\n    }\n}\n\nfunction setOffsetToUTC (keepLocalTime) {\n    return this.utcOffset(0, keepLocalTime);\n}\n\nfunction setOffsetToLocal (keepLocalTime) {\n    if (this._isUTC) {\n        this.utcOffset(0, keepLocalTime);\n        this._isUTC = false;\n\n        if (keepLocalTime) {\n            this.subtract(getDateOffset(this), 'm');\n        }\n    }\n    return this;\n}\n\nfunction setOffsetToParsedOffset () {\n    if (this._tzm != null) {\n        this.utcOffset(this._tzm, false, true);\n    } else if (typeof this._i === 'string') {\n        var tZone = offsetFromString(matchOffset, this._i);\n        if (tZone != null) {\n            this.utcOffset(tZone);\n        }\n        else {\n            this.utcOffset(0, true);\n        }\n    }\n    return this;\n}\n\nfunction hasAlignedHourOffset (input) {\n    if (!this.isValid()) {\n        return false;\n    }\n    input = input ? createLocal(input).utcOffset() : 0;\n\n    return (this.utcOffset() - input) % 60 === 0;\n}\n\nfunction isDaylightSavingTime () {\n    return (\n        this.utcOffset() > this.clone().month(0).utcOffset() ||\n        this.utcOffset() > this.clone().month(5).utcOffset()\n    );\n}\n\nfunction isDaylightSavingTimeShifted () {\n    if (!isUndefined(this._isDSTShifted)) {\n        return this._isDSTShifted;\n    }\n\n    var c = {};\n\n    copyConfig(c, this);\n    c = prepareConfig(c);\n\n    if (c._a) {\n        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n        this._isDSTShifted = this.isValid() &&\n            compareArrays(c._a, other.toArray()) > 0;\n    } else {\n        this._isDSTShifted = false;\n    }\n\n    return this._isDSTShifted;\n}\n\nfunction isLocal () {\n    return this.isValid() ? !this._isUTC : false;\n}\n\nfunction isUtcOffset () {\n    return this.isValid() ? this._isUTC : false;\n}\n\nfunction isUtc () {\n    return this.isValid() ? this._isUTC && this._offset === 0 : false;\n}\n\n// ASP.NET json date format regex\nvar aspNetRegex = /^(\\-)?(?:(\\d*)[. ])?(\\d+)\\:(\\d+)(?:\\:(\\d+)(\\.\\d*)?)?$/;\n\n// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n// and further modified to allow for strings containing both week and day\nvar isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;\n\nfunction createDuration (input, key) {\n    var duration = input,\n        // matching against regexp is expensive, do it on demand\n        match = null,\n        sign,\n        ret,\n        diffRes;\n\n    if (isDuration(input)) {\n        duration = {\n            ms : input._milliseconds,\n            d  : input._days,\n            M  : input._months\n        };\n    } else if (isNumber(input)) {\n        duration = {};\n        if (key) {\n            duration[key] = input;\n        } else {\n            duration.milliseconds = input;\n        }\n    } else if (!!(match = aspNetRegex.exec(input))) {\n        sign = (match[1] === '-') ? -1 : 1;\n        duration = {\n            y  : 0,\n            d  : toInt(match[DATE])                         * sign,\n            h  : toInt(match[HOUR])                         * sign,\n            m  : toInt(match[MINUTE])                       * sign,\n            s  : toInt(match[SECOND])                       * sign,\n            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n        };\n    } else if (!!(match = isoRegex.exec(input))) {\n        sign = (match[1] === '-') ? -1 : 1;\n        duration = {\n            y : parseIso(match[2], sign),\n            M : parseIso(match[3], sign),\n            w : parseIso(match[4], sign),\n            d : parseIso(match[5], sign),\n            h : parseIso(match[6], sign),\n            m : parseIso(match[7], sign),\n            s : parseIso(match[8], sign)\n        };\n    } else if (duration == null) {// checks for null or undefined\n        duration = {};\n    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n\n        duration = {};\n        duration.ms = diffRes.milliseconds;\n        duration.M = diffRes.months;\n    }\n\n    ret = new Duration(duration);\n\n    if (isDuration(input) && hasOwnProp(input, '_locale')) {\n        ret._locale = input._locale;\n    }\n\n    return ret;\n}\n\ncreateDuration.fn = Duration.prototype;\ncreateDuration.invalid = createInvalid$1;\n\nfunction parseIso (inp, sign) {\n    // We'd normally use ~~inp for this, but unfortunately it also\n    // converts floats to ints.\n    // inp may be undefined, so careful calling replace on it.\n    var res = inp && parseFloat(inp.replace(',', '.'));\n    // apply sign while we're at it\n    return (isNaN(res) ? 0 : res) * sign;\n}\n\nfunction positiveMomentsDifference(base, other) {\n    var res = {milliseconds: 0, months: 0};\n\n    res.months = other.month() - base.month() +\n        (other.year() - base.year()) * 12;\n    if (base.clone().add(res.months, 'M').isAfter(other)) {\n        --res.months;\n    }\n\n    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));\n\n    return res;\n}\n\nfunction momentsDifference(base, other) {\n    var res;\n    if (!(base.isValid() && other.isValid())) {\n        return {milliseconds: 0, months: 0};\n    }\n\n    other = cloneWithOffset(other, base);\n    if (base.isBefore(other)) {\n        res = positiveMomentsDifference(base, other);\n    } else {\n        res = positiveMomentsDifference(other, base);\n        res.milliseconds = -res.milliseconds;\n        res.months = -res.months;\n    }\n\n    return res;\n}\n\n// TODO: remove 'name' arg after deprecation is removed\nfunction createAdder(direction, name) {\n    return function (val, period) {\n        var dur, tmp;\n        //invert the arguments, but complain about it\n        if (period !== null && !isNaN(+period)) {\n            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +\n            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n            tmp = val; val = period; period = tmp;\n        }\n\n        val = typeof val === 'string' ? +val : val;\n        dur = createDuration(val, period);\n        addSubtract(this, dur, direction);\n        return this;\n    };\n}\n\nfunction addSubtract (mom, duration, isAdding, updateOffset) {\n    var milliseconds = duration._milliseconds,\n        days = absRound(duration._days),\n        months = absRound(duration._months);\n\n    if (!mom.isValid()) {\n        // No op\n        return;\n    }\n\n    updateOffset = updateOffset == null ? true : updateOffset;\n\n    if (milliseconds) {\n        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n    }\n    if (days) {\n        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n    }\n    if (months) {\n        setMonth(mom, get(mom, 'Month') + months * isAdding);\n    }\n    if (updateOffset) {\n        hooks.updateOffset(mom, days || months);\n    }\n}\n\nvar add      = createAdder(1, 'add');\nvar subtract = createAdder(-1, 'subtract');\n\nfunction getCalendarFormat(myMoment, now) {\n    var diff = myMoment.diff(now, 'days', true);\n    return diff < -6 ? 'sameElse' :\n            diff < -1 ? 'lastWeek' :\n            diff < 0 ? 'lastDay' :\n            diff < 1 ? 'sameDay' :\n            diff < 2 ? 'nextDay' :\n            diff < 7 ? 'nextWeek' : 'sameElse';\n}\n\nfunction calendar$1 (time, formats) {\n    // We want to compare the start of today, vs this.\n    // Getting start-of-today depends on whether we're local/utc/offset or not.\n    var now = time || createLocal(),\n        sod = cloneWithOffset(now, this).startOf('day'),\n        format = hooks.calendarFormat(this, sod) || 'sameElse';\n\n    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n\n    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n}\n\nfunction clone () {\n    return new Moment(this);\n}\n\nfunction isAfter (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() > localInput.valueOf();\n    } else {\n        return localInput.valueOf() < this.clone().startOf(units).valueOf();\n    }\n}\n\nfunction isBefore (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() < localInput.valueOf();\n    } else {\n        return this.clone().endOf(units).valueOf() < localInput.valueOf();\n    }\n}\n\nfunction isBetween (from, to, units, inclusivity) {\n    inclusivity = inclusivity || '()';\n    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&\n        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));\n}\n\nfunction isSame (input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input),\n        inputMs;\n    if (!(this.isValid() && localInput.isValid())) {\n        return false;\n    }\n    units = normalizeUnits(units || 'millisecond');\n    if (units === 'millisecond') {\n        return this.valueOf() === localInput.valueOf();\n    } else {\n        inputMs = localInput.valueOf();\n        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n    }\n}\n\nfunction isSameOrAfter (input, units) {\n    return this.isSame(input, units) || this.isAfter(input,units);\n}\n\nfunction isSameOrBefore (input, units) {\n    return this.isSame(input, units) || this.isBefore(input,units);\n}\n\nfunction diff (input, units, asFloat) {\n    var that,\n        zoneDelta,\n        delta, output;\n\n    if (!this.isValid()) {\n        return NaN;\n    }\n\n    that = cloneWithOffset(input, this);\n\n    if (!that.isValid()) {\n        return NaN;\n    }\n\n    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n\n    units = normalizeUnits(units);\n\n    if (units === 'year' || units === 'month' || units === 'quarter') {\n        output = monthDiff(this, that);\n        if (units === 'quarter') {\n            output = output / 3;\n        } else if (units === 'year') {\n            output = output / 12;\n        }\n    } else {\n        delta = this - that;\n        output = units === 'second' ? delta / 1e3 : // 1000\n            units === 'minute' ? delta / 6e4 : // 1000 * 60\n            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60\n            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst\n            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst\n            delta;\n    }\n    return asFloat ? output : absFloor(output);\n}\n\nfunction monthDiff (a, b) {\n    // difference in months\n    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),\n        // b is in (anchor - 1 month, anchor + 1 month)\n        anchor = a.clone().add(wholeMonthDiff, 'months'),\n        anchor2, adjust;\n\n    if (b - anchor < 0) {\n        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');\n        // linear across the month\n        adjust = (b - anchor) / (anchor - anchor2);\n    } else {\n        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');\n        // linear across the month\n        adjust = (b - anchor) / (anchor2 - anchor);\n    }\n\n    //check for negative zero, return zero if negative zero\n    return -(wholeMonthDiff + adjust) || 0;\n}\n\nhooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\nhooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\nfunction toString () {\n    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n}\n\nfunction toISOString() {\n    if (!this.isValid()) {\n        return null;\n    }\n    var m = this.clone().utc();\n    if (m.year() < 0 || m.year() > 9999) {\n        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n    }\n    if (isFunction(Date.prototype.toISOString)) {\n        // native implementation is ~50x faster, use it when we can\n        return this.toDate().toISOString();\n    }\n    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');\n}\n\n/**\n * Return a human readable representation of a moment that can\n * also be evaluated to get a new moment which is the same\n *\n * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n */\nfunction inspect () {\n    if (!this.isValid()) {\n        return 'moment.invalid(/* ' + this._i + ' */)';\n    }\n    var func = 'moment';\n    var zone = '';\n    if (!this.isLocal()) {\n        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n        zone = 'Z';\n    }\n    var prefix = '[' + func + '(\"]';\n    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';\n    var datetime = '-MM-DD[T]HH:mm:ss.SSS';\n    var suffix = zone + '[\")]';\n\n    return this.format(prefix + year + datetime + suffix);\n}\n\nfunction format (inputString) {\n    if (!inputString) {\n        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n    }\n    var output = formatMoment(this, inputString);\n    return this.localeData().postformat(output);\n}\n\nfunction from (time, withoutSuffix) {\n    if (this.isValid() &&\n            ((isMoment(time) && time.isValid()) ||\n             createLocal(time).isValid())) {\n        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n        return this.localeData().invalidDate();\n    }\n}\n\nfunction fromNow (withoutSuffix) {\n    return this.from(createLocal(), withoutSuffix);\n}\n\nfunction to (time, withoutSuffix) {\n    if (this.isValid() &&\n            ((isMoment(time) && time.isValid()) ||\n             createLocal(time).isValid())) {\n        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n        return this.localeData().invalidDate();\n    }\n}\n\nfunction toNow (withoutSuffix) {\n    return this.to(createLocal(), withoutSuffix);\n}\n\n// If passed a locale key, it will set the locale for this\n// instance.  Otherwise, it will return the locale configuration\n// variables for this instance.\nfunction locale (key) {\n    var newLocaleData;\n\n    if (key === undefined) {\n        return this._locale._abbr;\n    } else {\n        newLocaleData = getLocale(key);\n        if (newLocaleData != null) {\n            this._locale = newLocaleData;\n        }\n        return this;\n    }\n}\n\nvar lang = deprecate(\n    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',\n    function (key) {\n        if (key === undefined) {\n            return this.localeData();\n        } else {\n            return this.locale(key);\n        }\n    }\n);\n\nfunction localeData () {\n    return this._locale;\n}\n\nfunction startOf (units) {\n    units = normalizeUnits(units);\n    // the following switch intentionally omits break keywords\n    // to utilize falling through the cases.\n    switch (units) {\n        case 'year':\n            this.month(0);\n            /* falls through */\n        case 'quarter':\n        case 'month':\n            this.date(1);\n            /* falls through */\n        case 'week':\n        case 'isoWeek':\n        case 'day':\n        case 'date':\n            this.hours(0);\n            /* falls through */\n        case 'hour':\n            this.minutes(0);\n            /* falls through */\n        case 'minute':\n            this.seconds(0);\n            /* falls through */\n        case 'second':\n            this.milliseconds(0);\n    }\n\n    // weeks are a special case\n    if (units === 'week') {\n        this.weekday(0);\n    }\n    if (units === 'isoWeek') {\n        this.isoWeekday(1);\n    }\n\n    // quarters are also special\n    if (units === 'quarter') {\n        this.month(Math.floor(this.month() / 3) * 3);\n    }\n\n    return this;\n}\n\nfunction endOf (units) {\n    units = normalizeUnits(units);\n    if (units === undefined || units === 'millisecond') {\n        return this;\n    }\n\n    // 'date' is an alias for 'day', so it should be considered as such.\n    if (units === 'date') {\n        units = 'day';\n    }\n\n    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');\n}\n\nfunction valueOf () {\n    return this._d.valueOf() - ((this._offset || 0) * 60000);\n}\n\nfunction unix () {\n    return Math.floor(this.valueOf() / 1000);\n}\n\nfunction toDate () {\n    return new Date(this.valueOf());\n}\n\nfunction toArray () {\n    var m = this;\n    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n}\n\nfunction toObject () {\n    var m = this;\n    return {\n        years: m.year(),\n        months: m.month(),\n        date: m.date(),\n        hours: m.hours(),\n        minutes: m.minutes(),\n        seconds: m.seconds(),\n        milliseconds: m.milliseconds()\n    };\n}\n\nfunction toJSON () {\n    // new Date(NaN).toJSON() === null\n    return this.isValid() ? this.toISOString() : null;\n}\n\nfunction isValid$2 () {\n    return isValid(this);\n}\n\nfunction parsingFlags () {\n    return extend({}, getParsingFlags(this));\n}\n\nfunction invalidAt () {\n    return getParsingFlags(this).overflow;\n}\n\nfunction creationData() {\n    return {\n        input: this._i,\n        format: this._f,\n        locale: this._locale,\n        isUTC: this._isUTC,\n        strict: this._strict\n    };\n}\n\n// FORMATTING\n\naddFormatToken(0, ['gg', 2], 0, function () {\n    return this.weekYear() % 100;\n});\n\naddFormatToken(0, ['GG', 2], 0, function () {\n    return this.isoWeekYear() % 100;\n});\n\nfunction addWeekYearFormatToken (token, getter) {\n    addFormatToken(0, [token, token.length], 0, getter);\n}\n\naddWeekYearFormatToken('gggg',     'weekYear');\naddWeekYearFormatToken('ggggg',    'weekYear');\naddWeekYearFormatToken('GGGG',  'isoWeekYear');\naddWeekYearFormatToken('GGGGG', 'isoWeekYear');\n\n// ALIASES\n\naddUnitAlias('weekYear', 'gg');\naddUnitAlias('isoWeekYear', 'GG');\n\n// PRIORITY\n\naddUnitPriority('weekYear', 1);\naddUnitPriority('isoWeekYear', 1);\n\n\n// PARSING\n\naddRegexToken('G',      matchSigned);\naddRegexToken('g',      matchSigned);\naddRegexToken('GG',     match1to2, match2);\naddRegexToken('gg',     match1to2, match2);\naddRegexToken('GGGG',   match1to4, match4);\naddRegexToken('gggg',   match1to4, match4);\naddRegexToken('GGGGG',  match1to6, match6);\naddRegexToken('ggggg',  match1to6, match6);\n\naddWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n    week[token.substr(0, 2)] = toInt(input);\n});\n\naddWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n    week[token] = hooks.parseTwoDigitYear(input);\n});\n\n// MOMENTS\n\nfunction getSetWeekYear (input) {\n    return getSetWeekYearHelper.call(this,\n            input,\n            this.week(),\n            this.weekday(),\n            this.localeData()._week.dow,\n            this.localeData()._week.doy);\n}\n\nfunction getSetISOWeekYear (input) {\n    return getSetWeekYearHelper.call(this,\n            input, this.isoWeek(), this.isoWeekday(), 1, 4);\n}\n\nfunction getISOWeeksInYear () {\n    return weeksInYear(this.year(), 1, 4);\n}\n\nfunction getWeeksInYear () {\n    var weekInfo = this.localeData()._week;\n    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n}\n\nfunction getSetWeekYearHelper(input, week, weekday, dow, doy) {\n    var weeksTarget;\n    if (input == null) {\n        return weekOfYear(this, dow, doy).year;\n    } else {\n        weeksTarget = weeksInYear(input, dow, doy);\n        if (week > weeksTarget) {\n            week = weeksTarget;\n        }\n        return setWeekAll.call(this, input, week, weekday, dow, doy);\n    }\n}\n\nfunction setWeekAll(weekYear, week, weekday, dow, doy) {\n    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n\n    this.year(date.getUTCFullYear());\n    this.month(date.getUTCMonth());\n    this.date(date.getUTCDate());\n    return this;\n}\n\n// FORMATTING\n\naddFormatToken('Q', 0, 'Qo', 'quarter');\n\n// ALIASES\n\naddUnitAlias('quarter', 'Q');\n\n// PRIORITY\n\naddUnitPriority('quarter', 7);\n\n// PARSING\n\naddRegexToken('Q', match1);\naddParseToken('Q', function (input, array) {\n    array[MONTH] = (toInt(input) - 1) * 3;\n});\n\n// MOMENTS\n\nfunction getSetQuarter (input) {\n    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n}\n\n// FORMATTING\n\naddFormatToken('D', ['DD', 2], 'Do', 'date');\n\n// ALIASES\n\naddUnitAlias('date', 'D');\n\n// PRIOROITY\naddUnitPriority('date', 9);\n\n// PARSING\n\naddRegexToken('D',  match1to2);\naddRegexToken('DD', match1to2, match2);\naddRegexToken('Do', function (isStrict, locale) {\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    return isStrict ?\n      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :\n      locale._dayOfMonthOrdinalParseLenient;\n});\n\naddParseToken(['D', 'DD'], DATE);\naddParseToken('Do', function (input, array) {\n    array[DATE] = toInt(input.match(match1to2)[0], 10);\n});\n\n// MOMENTS\n\nvar getSetDayOfMonth = makeGetSet('Date', true);\n\n// FORMATTING\n\naddFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');\n\n// ALIASES\n\naddUnitAlias('dayOfYear', 'DDD');\n\n// PRIORITY\naddUnitPriority('dayOfYear', 4);\n\n// PARSING\n\naddRegexToken('DDD',  match1to3);\naddRegexToken('DDDD', match3);\naddParseToken(['DDD', 'DDDD'], function (input, array, config) {\n    config._dayOfYear = toInt(input);\n});\n\n// HELPERS\n\n// MOMENTS\n\nfunction getSetDayOfYear (input) {\n    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');\n}\n\n// FORMATTING\n\naddFormatToken('m', ['mm', 2], 0, 'minute');\n\n// ALIASES\n\naddUnitAlias('minute', 'm');\n\n// PRIORITY\n\naddUnitPriority('minute', 14);\n\n// PARSING\n\naddRegexToken('m',  match1to2);\naddRegexToken('mm', match1to2, match2);\naddParseToken(['m', 'mm'], MINUTE);\n\n// MOMENTS\n\nvar getSetMinute = makeGetSet('Minutes', false);\n\n// FORMATTING\n\naddFormatToken('s', ['ss', 2], 0, 'second');\n\n// ALIASES\n\naddUnitAlias('second', 's');\n\n// PRIORITY\n\naddUnitPriority('second', 15);\n\n// PARSING\n\naddRegexToken('s',  match1to2);\naddRegexToken('ss', match1to2, match2);\naddParseToken(['s', 'ss'], SECOND);\n\n// MOMENTS\n\nvar getSetSecond = makeGetSet('Seconds', false);\n\n// FORMATTING\n\naddFormatToken('S', 0, 0, function () {\n    return ~~(this.millisecond() / 100);\n});\n\naddFormatToken(0, ['SS', 2], 0, function () {\n    return ~~(this.millisecond() / 10);\n});\n\naddFormatToken(0, ['SSS', 3], 0, 'millisecond');\naddFormatToken(0, ['SSSS', 4], 0, function () {\n    return this.millisecond() * 10;\n});\naddFormatToken(0, ['SSSSS', 5], 0, function () {\n    return this.millisecond() * 100;\n});\naddFormatToken(0, ['SSSSSS', 6], 0, function () {\n    return this.millisecond() * 1000;\n});\naddFormatToken(0, ['SSSSSSS', 7], 0, function () {\n    return this.millisecond() * 10000;\n});\naddFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n    return this.millisecond() * 100000;\n});\naddFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n    return this.millisecond() * 1000000;\n});\n\n\n// ALIASES\n\naddUnitAlias('millisecond', 'ms');\n\n// PRIORITY\n\naddUnitPriority('millisecond', 16);\n\n// PARSING\n\naddRegexToken('S',    match1to3, match1);\naddRegexToken('SS',   match1to3, match2);\naddRegexToken('SSS',  match1to3, match3);\n\nvar token;\nfor (token = 'SSSS'; token.length <= 9; token += 'S') {\n    addRegexToken(token, matchUnsigned);\n}\n\nfunction parseMs(input, array) {\n    array[MILLISECOND] = toInt(('0.' + input) * 1000);\n}\n\nfor (token = 'S'; token.length <= 9; token += 'S') {\n    addParseToken(token, parseMs);\n}\n// MOMENTS\n\nvar getSetMillisecond = makeGetSet('Milliseconds', false);\n\n// FORMATTING\n\naddFormatToken('z',  0, 0, 'zoneAbbr');\naddFormatToken('zz', 0, 0, 'zoneName');\n\n// MOMENTS\n\nfunction getZoneAbbr () {\n    return this._isUTC ? 'UTC' : '';\n}\n\nfunction getZoneName () {\n    return this._isUTC ? 'Coordinated Universal Time' : '';\n}\n\nvar proto = Moment.prototype;\n\nproto.add               = add;\nproto.calendar          = calendar$1;\nproto.clone             = clone;\nproto.diff              = diff;\nproto.endOf             = endOf;\nproto.format            = format;\nproto.from              = from;\nproto.fromNow           = fromNow;\nproto.to                = to;\nproto.toNow             = toNow;\nproto.get               = stringGet;\nproto.invalidAt         = invalidAt;\nproto.isAfter           = isAfter;\nproto.isBefore          = isBefore;\nproto.isBetween         = isBetween;\nproto.isSame            = isSame;\nproto.isSameOrAfter     = isSameOrAfter;\nproto.isSameOrBefore    = isSameOrBefore;\nproto.isValid           = isValid$2;\nproto.lang              = lang;\nproto.locale            = locale;\nproto.localeData        = localeData;\nproto.max               = prototypeMax;\nproto.min               = prototypeMin;\nproto.parsingFlags      = parsingFlags;\nproto.set               = stringSet;\nproto.startOf           = startOf;\nproto.subtract          = subtract;\nproto.toArray           = toArray;\nproto.toObject          = toObject;\nproto.toDate            = toDate;\nproto.toISOString       = toISOString;\nproto.inspect           = inspect;\nproto.toJSON            = toJSON;\nproto.toString          = toString;\nproto.unix              = unix;\nproto.valueOf           = valueOf;\nproto.creationData      = creationData;\n\n// Year\nproto.year       = getSetYear;\nproto.isLeapYear = getIsLeapYear;\n\n// Week Year\nproto.weekYear    = getSetWeekYear;\nproto.isoWeekYear = getSetISOWeekYear;\n\n// Quarter\nproto.quarter = proto.quarters = getSetQuarter;\n\n// Month\nproto.month       = getSetMonth;\nproto.daysInMonth = getDaysInMonth;\n\n// Week\nproto.week           = proto.weeks        = getSetWeek;\nproto.isoWeek        = proto.isoWeeks     = getSetISOWeek;\nproto.weeksInYear    = getWeeksInYear;\nproto.isoWeeksInYear = getISOWeeksInYear;\n\n// Day\nproto.date       = getSetDayOfMonth;\nproto.day        = proto.days             = getSetDayOfWeek;\nproto.weekday    = getSetLocaleDayOfWeek;\nproto.isoWeekday = getSetISODayOfWeek;\nproto.dayOfYear  = getSetDayOfYear;\n\n// Hour\nproto.hour = proto.hours = getSetHour;\n\n// Minute\nproto.minute = proto.minutes = getSetMinute;\n\n// Second\nproto.second = proto.seconds = getSetSecond;\n\n// Millisecond\nproto.millisecond = proto.milliseconds = getSetMillisecond;\n\n// Offset\nproto.utcOffset            = getSetOffset;\nproto.utc                  = setOffsetToUTC;\nproto.local                = setOffsetToLocal;\nproto.parseZone            = setOffsetToParsedOffset;\nproto.hasAlignedHourOffset = hasAlignedHourOffset;\nproto.isDST                = isDaylightSavingTime;\nproto.isLocal              = isLocal;\nproto.isUtcOffset          = isUtcOffset;\nproto.isUtc                = isUtc;\nproto.isUTC                = isUtc;\n\n// Timezone\nproto.zoneAbbr = getZoneAbbr;\nproto.zoneName = getZoneName;\n\n// Deprecations\nproto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\nproto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\nproto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);\nproto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\nproto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\nfunction createUnix (input) {\n    return createLocal(input * 1000);\n}\n\nfunction createInZone () {\n    return createLocal.apply(null, arguments).parseZone();\n}\n\nfunction preParsePostFormat (string) {\n    return string;\n}\n\nvar proto$1 = Locale.prototype;\n\nproto$1.calendar        = calendar;\nproto$1.longDateFormat  = longDateFormat;\nproto$1.invalidDate     = invalidDate;\nproto$1.ordinal         = ordinal;\nproto$1.preparse        = preParsePostFormat;\nproto$1.postformat      = preParsePostFormat;\nproto$1.relativeTime    = relativeTime;\nproto$1.pastFuture      = pastFuture;\nproto$1.set             = set;\n\n// Month\nproto$1.months            =        localeMonths;\nproto$1.monthsShort       =        localeMonthsShort;\nproto$1.monthsParse       =        localeMonthsParse;\nproto$1.monthsRegex       = monthsRegex;\nproto$1.monthsShortRegex  = monthsShortRegex;\n\n// Week\nproto$1.week = localeWeek;\nproto$1.firstDayOfYear = localeFirstDayOfYear;\nproto$1.firstDayOfWeek = localeFirstDayOfWeek;\n\n// Day of Week\nproto$1.weekdays       =        localeWeekdays;\nproto$1.weekdaysMin    =        localeWeekdaysMin;\nproto$1.weekdaysShort  =        localeWeekdaysShort;\nproto$1.weekdaysParse  =        localeWeekdaysParse;\n\nproto$1.weekdaysRegex       =        weekdaysRegex;\nproto$1.weekdaysShortRegex  =        weekdaysShortRegex;\nproto$1.weekdaysMinRegex    =        weekdaysMinRegex;\n\n// Hours\nproto$1.isPM = localeIsPM;\nproto$1.meridiem = localeMeridiem;\n\nfunction get$1 (format, index, field, setter) {\n    var locale = getLocale();\n    var utc = createUTC().set(setter, index);\n    return locale[field](utc, format);\n}\n\nfunction listMonthsImpl (format, index, field) {\n    if (isNumber(format)) {\n        index = format;\n        format = undefined;\n    }\n\n    format = format || '';\n\n    if (index != null) {\n        return get$1(format, index, field, 'month');\n    }\n\n    var i;\n    var out = [];\n    for (i = 0; i < 12; i++) {\n        out[i] = get$1(format, i, field, 'month');\n    }\n    return out;\n}\n\n// ()\n// (5)\n// (fmt, 5)\n// (fmt)\n// (true)\n// (true, 5)\n// (true, fmt, 5)\n// (true, fmt)\nfunction listWeekdaysImpl (localeSorted, format, index, field) {\n    if (typeof localeSorted === 'boolean') {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n    } else {\n        format = localeSorted;\n        index = format;\n        localeSorted = false;\n\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n\n        format = format || '';\n    }\n\n    var locale = getLocale(),\n        shift = localeSorted ? locale._week.dow : 0;\n\n    if (index != null) {\n        return get$1(format, (index + shift) % 7, field, 'day');\n    }\n\n    var i;\n    var out = [];\n    for (i = 0; i < 7; i++) {\n        out[i] = get$1(format, (i + shift) % 7, field, 'day');\n    }\n    return out;\n}\n\nfunction listMonths (format, index) {\n    return listMonthsImpl(format, index, 'months');\n}\n\nfunction listMonthsShort (format, index) {\n    return listMonthsImpl(format, index, 'monthsShort');\n}\n\nfunction listWeekdays (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n}\n\nfunction listWeekdaysShort (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n}\n\nfunction listWeekdaysMin (localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n}\n\ngetSetGlobalLocale('en', {\n    dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n    ordinal : function (number) {\n        var b = number % 10,\n            output = (toInt(number % 100 / 10) === 1) ? 'th' :\n            (b === 1) ? 'st' :\n            (b === 2) ? 'nd' :\n            (b === 3) ? 'rd' : 'th';\n        return number + output;\n    }\n});\n\n// Side effect imports\nhooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\nhooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n\nvar mathAbs = Math.abs;\n\nfunction abs () {\n    var data           = this._data;\n\n    this._milliseconds = mathAbs(this._milliseconds);\n    this._days         = mathAbs(this._days);\n    this._months       = mathAbs(this._months);\n\n    data.milliseconds  = mathAbs(data.milliseconds);\n    data.seconds       = mathAbs(data.seconds);\n    data.minutes       = mathAbs(data.minutes);\n    data.hours         = mathAbs(data.hours);\n    data.months        = mathAbs(data.months);\n    data.years         = mathAbs(data.years);\n\n    return this;\n}\n\nfunction addSubtract$1 (duration, input, value, direction) {\n    var other = createDuration(input, value);\n\n    duration._milliseconds += direction * other._milliseconds;\n    duration._days         += direction * other._days;\n    duration._months       += direction * other._months;\n\n    return duration._bubble();\n}\n\n// supports only 2.0-style add(1, 's') or add(duration)\nfunction add$1 (input, value) {\n    return addSubtract$1(this, input, value, 1);\n}\n\n// supports only 2.0-style subtract(1, 's') or subtract(duration)\nfunction subtract$1 (input, value) {\n    return addSubtract$1(this, input, value, -1);\n}\n\nfunction absCeil (number) {\n    if (number < 0) {\n        return Math.floor(number);\n    } else {\n        return Math.ceil(number);\n    }\n}\n\nfunction bubble () {\n    var milliseconds = this._milliseconds;\n    var days         = this._days;\n    var months       = this._months;\n    var data         = this._data;\n    var seconds, minutes, hours, years, monthsFromDays;\n\n    // if we have a mix of positive and negative values, bubble down first\n    // check: https://github.com/moment/moment/issues/2166\n    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||\n            (milliseconds <= 0 && days <= 0 && months <= 0))) {\n        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n        days = 0;\n        months = 0;\n    }\n\n    // The following code bubbles up values, see the tests for\n    // examples of what that means.\n    data.milliseconds = milliseconds % 1000;\n\n    seconds           = absFloor(milliseconds / 1000);\n    data.seconds      = seconds % 60;\n\n    minutes           = absFloor(seconds / 60);\n    data.minutes      = minutes % 60;\n\n    hours             = absFloor(minutes / 60);\n    data.hours        = hours % 24;\n\n    days += absFloor(hours / 24);\n\n    // convert days to months\n    monthsFromDays = absFloor(daysToMonths(days));\n    months += monthsFromDays;\n    days -= absCeil(monthsToDays(monthsFromDays));\n\n    // 12 months -> 1 year\n    years = absFloor(months / 12);\n    months %= 12;\n\n    data.days   = days;\n    data.months = months;\n    data.years  = years;\n\n    return this;\n}\n\nfunction daysToMonths (days) {\n    // 400 years have 146097 days (taking into account leap year rules)\n    // 400 years have 12 months === 4800\n    return days * 4800 / 146097;\n}\n\nfunction monthsToDays (months) {\n    // the reverse of daysToMonths\n    return months * 146097 / 4800;\n}\n\nfunction as (units) {\n    if (!this.isValid()) {\n        return NaN;\n    }\n    var days;\n    var months;\n    var milliseconds = this._milliseconds;\n\n    units = normalizeUnits(units);\n\n    if (units === 'month' || units === 'year') {\n        days   = this._days   + milliseconds / 864e5;\n        months = this._months + daysToMonths(days);\n        return units === 'month' ? months : months / 12;\n    } else {\n        // handle milliseconds separately because of floating point math errors (issue #1867)\n        days = this._days + Math.round(monthsToDays(this._months));\n        switch (units) {\n            case 'week'   : return days / 7     + milliseconds / 6048e5;\n            case 'day'    : return days         + milliseconds / 864e5;\n            case 'hour'   : return days * 24    + milliseconds / 36e5;\n            case 'minute' : return days * 1440  + milliseconds / 6e4;\n            case 'second' : return days * 86400 + milliseconds / 1000;\n            // Math.floor prevents floating point math errors here\n            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;\n            default: throw new Error('Unknown unit ' + units);\n        }\n    }\n}\n\n// TODO: Use this.as('ms')?\nfunction valueOf$1 () {\n    if (!this.isValid()) {\n        return NaN;\n    }\n    return (\n        this._milliseconds +\n        this._days * 864e5 +\n        (this._months % 12) * 2592e6 +\n        toInt(this._months / 12) * 31536e6\n    );\n}\n\nfunction makeAs (alias) {\n    return function () {\n        return this.as(alias);\n    };\n}\n\nvar asMilliseconds = makeAs('ms');\nvar asSeconds      = makeAs('s');\nvar asMinutes      = makeAs('m');\nvar asHours        = makeAs('h');\nvar asDays         = makeAs('d');\nvar asWeeks        = makeAs('w');\nvar asMonths       = makeAs('M');\nvar asYears        = makeAs('y');\n\nfunction get$2 (units) {\n    units = normalizeUnits(units);\n    return this.isValid() ? this[units + 's']() : NaN;\n}\n\nfunction makeGetter(name) {\n    return function () {\n        return this.isValid() ? this._data[name] : NaN;\n    };\n}\n\nvar milliseconds = makeGetter('milliseconds');\nvar seconds      = makeGetter('seconds');\nvar minutes      = makeGetter('minutes');\nvar hours        = makeGetter('hours');\nvar days         = makeGetter('days');\nvar months       = makeGetter('months');\nvar years        = makeGetter('years');\n\nfunction weeks () {\n    return absFloor(this.days() / 7);\n}\n\nvar round = Math.round;\nvar thresholds = {\n    ss: 44,         // a few seconds to seconds\n    s : 45,         // seconds to minute\n    m : 45,         // minutes to hour\n    h : 22,         // hours to day\n    d : 26,         // days to month\n    M : 11          // months to year\n};\n\n// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\nfunction substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n}\n\nfunction relativeTime$1 (posNegDuration, withoutSuffix, locale) {\n    var duration = createDuration(posNegDuration).abs();\n    var seconds  = round(duration.as('s'));\n    var minutes  = round(duration.as('m'));\n    var hours    = round(duration.as('h'));\n    var days     = round(duration.as('d'));\n    var months   = round(duration.as('M'));\n    var years    = round(duration.as('y'));\n\n    var a = seconds <= thresholds.ss && ['s', seconds]  ||\n            seconds < thresholds.s   && ['ss', seconds] ||\n            minutes <= 1             && ['m']           ||\n            minutes < thresholds.m   && ['mm', minutes] ||\n            hours   <= 1             && ['h']           ||\n            hours   < thresholds.h   && ['hh', hours]   ||\n            days    <= 1             && ['d']           ||\n            days    < thresholds.d   && ['dd', days]    ||\n            months  <= 1             && ['M']           ||\n            months  < thresholds.M   && ['MM', months]  ||\n            years   <= 1             && ['y']           || ['yy', years];\n\n    a[2] = withoutSuffix;\n    a[3] = +posNegDuration > 0;\n    a[4] = locale;\n    return substituteTimeAgo.apply(null, a);\n}\n\n// This function allows you to set the rounding function for relative time strings\nfunction getSetRelativeTimeRounding (roundingFunction) {\n    if (roundingFunction === undefined) {\n        return round;\n    }\n    if (typeof(roundingFunction) === 'function') {\n        round = roundingFunction;\n        return true;\n    }\n    return false;\n}\n\n// This function allows you to set a threshold for relative time strings\nfunction getSetRelativeTimeThreshold (threshold, limit) {\n    if (thresholds[threshold] === undefined) {\n        return false;\n    }\n    if (limit === undefined) {\n        return thresholds[threshold];\n    }\n    thresholds[threshold] = limit;\n    if (threshold === 's') {\n        thresholds.ss = limit - 1;\n    }\n    return true;\n}\n\nfunction humanize (withSuffix) {\n    if (!this.isValid()) {\n        return this.localeData().invalidDate();\n    }\n\n    var locale = this.localeData();\n    var output = relativeTime$1(this, !withSuffix, locale);\n\n    if (withSuffix) {\n        output = locale.pastFuture(+this, output);\n    }\n\n    return locale.postformat(output);\n}\n\nvar abs$1 = Math.abs;\n\nfunction toISOString$1() {\n    // for ISO strings we do not use the normal bubbling rules:\n    //  * milliseconds bubble up until they become hours\n    //  * days do not bubble at all\n    //  * months bubble up until they become years\n    // This is because there is no context-free conversion between hours and days\n    // (think of clock changes)\n    // and also not between days and months (28-31 days per month)\n    if (!this.isValid()) {\n        return this.localeData().invalidDate();\n    }\n\n    var seconds = abs$1(this._milliseconds) / 1000;\n    var days         = abs$1(this._days);\n    var months       = abs$1(this._months);\n    var minutes, hours, years;\n\n    // 3600 seconds -> 60 minutes -> 1 hour\n    minutes           = absFloor(seconds / 60);\n    hours             = absFloor(minutes / 60);\n    seconds %= 60;\n    minutes %= 60;\n\n    // 12 months -> 1 year\n    years  = absFloor(months / 12);\n    months %= 12;\n\n\n    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n    var Y = years;\n    var M = months;\n    var D = days;\n    var h = hours;\n    var m = minutes;\n    var s = seconds;\n    var total = this.asSeconds();\n\n    if (!total) {\n        // this is the same as C#'s (Noda) and python (isodate)...\n        // but not other JS (goog.date)\n        return 'P0D';\n    }\n\n    return (total < 0 ? '-' : '') +\n        'P' +\n        (Y ? Y + 'Y' : '') +\n        (M ? M + 'M' : '') +\n        (D ? D + 'D' : '') +\n        ((h || m || s) ? 'T' : '') +\n        (h ? h + 'H' : '') +\n        (m ? m + 'M' : '') +\n        (s ? s + 'S' : '');\n}\n\nvar proto$2 = Duration.prototype;\n\nproto$2.isValid        = isValid$1;\nproto$2.abs            = abs;\nproto$2.add            = add$1;\nproto$2.subtract       = subtract$1;\nproto$2.as             = as;\nproto$2.asMilliseconds = asMilliseconds;\nproto$2.asSeconds      = asSeconds;\nproto$2.asMinutes      = asMinutes;\nproto$2.asHours        = asHours;\nproto$2.asDays         = asDays;\nproto$2.asWeeks        = asWeeks;\nproto$2.asMonths       = asMonths;\nproto$2.asYears        = asYears;\nproto$2.valueOf        = valueOf$1;\nproto$2._bubble        = bubble;\nproto$2.get            = get$2;\nproto$2.milliseconds   = milliseconds;\nproto$2.seconds        = seconds;\nproto$2.minutes        = minutes;\nproto$2.hours          = hours;\nproto$2.days           = days;\nproto$2.weeks          = weeks;\nproto$2.months         = months;\nproto$2.years          = years;\nproto$2.humanize       = humanize;\nproto$2.toISOString    = toISOString$1;\nproto$2.toString       = toISOString$1;\nproto$2.toJSON         = toISOString$1;\nproto$2.locale         = locale;\nproto$2.localeData     = localeData;\n\n// Deprecations\nproto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\nproto$2.lang = lang;\n\n// Side effect imports\n\n// FORMATTING\n\naddFormatToken('X', 0, 0, 'unix');\naddFormatToken('x', 0, 0, 'valueOf');\n\n// PARSING\n\naddRegexToken('x', matchSigned);\naddRegexToken('X', matchTimestamp);\naddParseToken('X', function (input, array, config) {\n    config._d = new Date(parseFloat(input, 10) * 1000);\n});\naddParseToken('x', function (input, array, config) {\n    config._d = new Date(toInt(input));\n});\n\n// Side effect imports\n\n\nhooks.version = '2.18.1';\n\nsetHookCallback(createLocal);\n\nhooks.fn                    = proto;\nhooks.min                   = min;\nhooks.max                   = max;\nhooks.now                   = now;\nhooks.utc                   = createUTC;\nhooks.unix                  = createUnix;\nhooks.months                = listMonths;\nhooks.isDate                = isDate;\nhooks.locale                = getSetGlobalLocale;\nhooks.invalid               = createInvalid;\nhooks.duration              = createDuration;\nhooks.isMoment              = isMoment;\nhooks.weekdays              = listWeekdays;\nhooks.parseZone             = createInZone;\nhooks.localeData            = getLocale;\nhooks.isDuration            = isDuration;\nhooks.monthsShort           = listMonthsShort;\nhooks.weekdaysMin           = listWeekdaysMin;\nhooks.defineLocale          = defineLocale;\nhooks.updateLocale          = updateLocale;\nhooks.locales               = listLocales;\nhooks.weekdaysShort         = listWeekdaysShort;\nhooks.normalizeUnits        = normalizeUnits;\nhooks.relativeTimeRounding = getSetRelativeTimeRounding;\nhooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\nhooks.calendarFormat        = getCalendarFormat;\nhooks.prototype             = proto;\n\nreturn hooks;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/moment/moment.js\n// module id = 33\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 34\n// module chunks = 0","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/is-buffer/index.js\n// module id = 35\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = require(\"../util/constants\");\nconst HeaderConstants = constants_1.Constants.HeaderConstants;\nconst DEFAULT_AUTHORIZATION_SCHEME = 'Bearer';\n/**\n * Creates a new TokenCredentials object.\n *\n * @constructor\n * @param {string} token               The token.\n * @param {string} authorizationScheme The authorization scheme.\n */\nclass TokenCredentials {\n    constructor(token, authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME) {\n        this.authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;\n        if (!token) {\n            throw new Error('token cannot be null or undefined.');\n        }\n        this.token = token;\n        this.authorizationScheme = authorizationScheme;\n    }\n    /**\n     * Signs a request with the Authentication header.\n     *\n     * @param {WebResource} The WebResource to be signed.\n     * @return {Promise<WebResource>} The signed request object.\n     */\n    signRequest(webResource) {\n        if (!webResource.headers)\n            webResource.headers = {};\n        webResource.headers[HeaderConstants.AUTHORIZATION] = `${this.authorizationScheme} ${this.token}`;\n        return Promise.resolve(webResource);\n    }\n}\nexports.TokenCredentials = TokenCredentials;\n//# sourceMappingURL=tokenCredentials.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/credentials/tokenCredentials.js\n// module id = 36\n// module chunks = 0","\"use strict\";\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = require(\"../util/constants\");\nconst HeaderConstants = constants_1.Constants.HeaderConstants;\nconst DEFAULT_AUTHORIZATION_SCHEME = 'Basic';\n/**\n * Creates a new BasicAuthenticationCredentials object.\n *\n * @constructor\n * @param {string} userName                 User name.\n * @param {string} password                 Password.\n * @param {string} [authorizationScheme]    The authorization scheme.\n */\nclass BasicAuthenticationCredentials {\n    constructor(userName, password, authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME) {\n        this.authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;\n        if (userName === null || userName === undefined || typeof userName.valueOf() !== 'string') {\n            throw new Error('userName cannot be null or undefined and must be of type string.');\n        }\n        if (password === null || password === undefined || typeof password.valueOf() !== 'string') {\n            throw new Error('password cannot be null or undefined and must be of type string.');\n        }\n        this.userName = userName;\n        this.password = password;\n        this.authorizationScheme = authorizationScheme;\n    }\n    /**\n     * Signs a request with the Authentication header.\n     *\n     * @param {WebResource} The WebResource to be signed.\n     * @returns {Promise<WebResource>} - The signed request object.\n     */\n    signRequest(webResource) {\n        const credentials = `${this.userName}:${this.password}`;\n        const encodedCredentials = `${this.authorizationScheme} ${Buffer.from(credentials).toString('base64')}`;\n        if (!webResource.headers)\n            webResource.headers = {};\n        webResource.headers[HeaderConstants.AUTHORIZATION] = encodedCredentials;\n        return Promise.resolve(webResource);\n    }\n}\nexports.BasicAuthenticationCredentials = BasicAuthenticationCredentials;\n//# sourceMappingURL=basicAuthenticationCredentials.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/ms-rest/dist/node/lib/credentials/basicAuthenticationCredentials.js\n// module id = 37\n// module chunks = 0","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License. See License.txt in the project root for license information. \n\nimport Constants from './util/constants';\nimport * as msRest from 'ms-rest';\nconst LroStates = Constants.LongRunningOperationStates;\n\n/**\n * @class\n * Initializes a new instance of the PollingState class.\n */\nexport default class PollingState {\n  /**\n   * @param {msRest.HttpOperationResponse} [response] - Response of the initial request that was made as a part of the asynchronous operation.\n   */\n  resultOfInitialRequest: msRest.HttpOperationResponse;\n  /**\n   * @param {msRest.RequestOptions} [optionsOfInitialRequest] - Request options that were provided as a part of the initial request.\n   */\n  optionsOfInitialRequest: msRest.RequestOptions;\n  /**\n   * @param {msRest.WebResource} [request] - provides information about the request made for polling.\n   */\n  request: msRest.WebResource;\n  /**\n   * @param {Response} [response] - The response object to extract longrunning operation status.\n   */\n  response: Response;\n  /**\n   * @param {any} [resource] - Provides information about the response body received in the polling request. Particularly useful when polling via provisioningState.\n   */\n  resource: any;\n  /**\n   * @param {number} [retryTimeout] - The timeout in seconds to retry on intermediate operation results. Default Value is 30.\n   */\n  retryTimeout?: number = 30;\n  /**\n   * @param {string} [azureAsyncOperationHeaderLink] - The url that is present in \"azure-asyncoperation\" response header.\n   */\n  azureAsyncOperationHeaderLink?: string;\n  /**\n   * @param {string} [locationHeaderLink] - The url that is present in \"Location\" response header.\n   */\n  locationHeaderLink?: string;\n  /**\n   * @param {string} [status] - The status of polling. \"Succeeded, Failed, Cancelled, Updating, Creating, etc.\"\n   */\n  status?: string;\n  /**\n   * @param {msRest.RestError} [error] - Provides information about the error that happened while polling.\n   */\n  error?: msRest.RestError;\n\n  constructor(resultOfInitialRequest: msRest.HttpOperationResponse, retryTimeout: number = 30) {\n    this.resultOfInitialRequest = resultOfInitialRequest;\n    this.retryTimeout = retryTimeout;\n    this.updateResponse(resultOfInitialRequest.response);\n    this.request = resultOfInitialRequest.request;\n    this.resource = resultOfInitialRequest.bodyAsJson;\n\n    switch (this.response.status) {\n      case 202:\n        this.status = LroStates.InProgress;\n        break;\n\n      case 204:\n        this.status = LroStates.Succeeded;\n        break;\n\n      case 201:\n        if (this.resource && this.resource.properties && this.resource.properties.provisioningState) {\n          this.status = this.resource.properties.provisioningState;\n        } else {\n          this.status = LroStates.InProgress;\n        }\n        break;\n\n      case 200:\n        if (this.resource && this.resource.properties && this.resource.properties.provisioningState) {\n          this.status = this.resource.properties.provisioningState;\n        } else {\n          this.status = LroStates.Succeeded;\n        }\n        break;\n\n      default:\n        this.status = LroStates.Failed;\n        break;\n    }\n  }\n\n  /**\n   * Update cached data using the provided response object\n   * @param {Response} [response] - provider response object.\n   */\n  updateResponse(response: Response) {\n    this.response = response;\n    if (response && response.headers) {\n      let asyncOperationHeader: string | null | undefined = response.headers.get('azure-asyncoperation');\n      let locationHeader: string | null | undefined = response.headers.get('location');\n      if (asyncOperationHeader) {\n        this.azureAsyncOperationHeaderLink = asyncOperationHeader;\n      }\n\n      if (locationHeader) {\n        this.locationHeaderLink = locationHeader;\n      }\n    }\n  }\n\n  /**\n   * Gets timeout in milliseconds. \n   * @returns {number} timeout\n   */\n  getTimeout() {\n    if (this.retryTimeout || this.retryTimeout === 0) {\n      return this.retryTimeout * 1000;\n    }\n    if (this.response) {\n      let retryAfter: string | null | undefined = this.response.headers.get('retry-after');\n      if (retryAfter) {\n        return parseInt(retryAfter) * 1000;\n      }\n    }\n    return 30 * 1000;\n  }\n\n  /**\n   * Returns long running operation result.\n   * @returns {msRest.HttpOperationResponse} HttpOperationResponse\n   */\n  getOperationResponse(): msRest.HttpOperationResponse {\n    let result = new msRest.HttpOperationResponse(this.request, this.response, this.response.body);\n    if (this.resource && typeof this.resource.valueOf() === 'string') {\n      result.bodyAsText = this.resource;\n      result.bodyAsJson = JSON.parse(this.resource);\n    } else {\n      result.bodyAsJson = this.resource;\n      result.bodyAsText = JSON.stringify(this.resource);\n    }\n    return result;\n  }\n\n  /**\n   * Returns an Error on operation failure.\n   * @param {Error} err - The error object.\n   * @returns {msRest.RestError} The RestError defined in the runtime.\n   */\n  getRestError(err?: Error): msRest.RestError {\n    let errMsg: string;\n    let errCode: string | null = null;\n\n    let error = new msRest.RestError('');\n    error.request = msRest.stripRequest(this.request);\n    error.response = this.response;\n    let parsedResponse = this.resultOfInitialRequest.bodyAsJson as { [key: string]: any };\n    \n    if (err && err.message) {\n      errMsg = `Long running operation failed with error: \"${err.message}\".`;\n    } else {\n      errMsg = `Long running operation failed with status: \"${this.status}\".`;\n    }\n\n    if (parsedResponse) {\n      if (parsedResponse.error && parsedResponse.error.message) {\n        errMsg = `Long running operation failed with error: \"${parsedResponse.error.message}\".`;\n      }\n      if (parsedResponse.error && parsedResponse.error.code) {\n        errCode = parsedResponse.error.code as string;\n      }\n    }\n\n    error.message = errMsg;\n    if (errCode) error.code = errCode;\n    error.body = parsedResponse;\n    return error;\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./lib/pollingState.ts","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License. See License.txt in the project root for license information.\r\n\r\n/**\r\n * @class\r\n * Provides additional information about an http error response returned from a Microsoft Azure service.\r\n */\r\nexport interface CloudError extends Error {\r\n  /**\r\n   * @property {string} code The error code parsed from the body of the http error response.\r\n   */\r\n  code: string;\r\n  /**\r\n  * @property {string} message The error message parsed from the body of the http error response.\r\n  */\r\n  message: string;\r\n  /**\r\n  * @property {string} [target] The target of the error.\r\n  */\r\n  target?: string;\r\n  /**\r\n  * @property {Array<CloudError>} [details] An array of CloudError objects specifying the details.\r\n  */\r\n  details?: Array<CloudError>;\r\n}\r\n\r\nexport const CloudErrorMapper = {\r\n  required: false,\r\n  serializedName: 'CloudError',\r\n  type: {\r\n    name: 'Composite',\r\n    className: 'CloudError',\r\n    modelProperties: {\r\n      code: {\r\n        required: true,\r\n        serializedName: 'code',\r\n        type: {\r\n          name: 'String'\r\n        }\r\n      },\r\n      message: {\r\n        required: true,\r\n        serializedName: 'message',\r\n        type: {\r\n          name: 'String'\r\n        }\r\n      },\r\n      target: {\r\n        required: false,\r\n        serializedName: 'target',\r\n        type: {\r\n          name: 'String'\r\n        }\r\n      },\r\n      details: {\r\n        required: false,\r\n        serializedName: 'details',\r\n        type: {\r\n          name: 'Sequence',\r\n          element: {\r\n            required: false,\r\n            serializedName: 'CloudErrorElementType',\r\n            type: {\r\n              name: 'Composite',\r\n              className: 'CloudError'\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n};\n\n\n// WEBPACK FOOTER //\n// ./lib/cloudError.ts","// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License. See License.txt in the project root for license information.\r\n\r\n/**\r\n * @class\r\n * An empty interface.\r\n */\r\nexport interface BaseResource { }\r\n\r\nexport const BaseResourcerMapper = {\r\n  required: false,\r\n  serializedName: 'BaseResource',\r\n  type: {\r\n    name: 'Composite',\r\n    className: 'BaseResource',\r\n    modelProperties: {\r\n    }\r\n  }\r\n};\n\n\n// WEBPACK FOOTER //\n// ./lib/baseResource.ts"],"sourceRoot":""}